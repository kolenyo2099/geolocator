<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Geolocation Verification Tool</title>

  <!-- Leaflet core with rotation support -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  
  <!-- Leaflet Rotation Plugin -->
  <script src="https://unpkg.com/leaflet-rotate@0.2.8/dist/leaflet-rotate-src.js"></script>

  <!-- Leaflet Geoman for drawing -->
  <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.14.2/dist/leaflet-geoman.css"/>
  <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.14.2/dist/leaflet-geoman.min.js"></script>

  <!-- Turf.js for angle calculations -->
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

  <!-- Leaflet Geocoder -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css"/>
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

  <!-- MarkerCluster -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <!-- Mapbox GL JS for 3D terrain view -->
  <link href='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css' rel='stylesheet' />
  <script src='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js'></script>

  <!-- PeakFinder API -->
  <script async type="text/javascript" src="https://www.peakfinder.com/script/peakfinder.1.0.min.js"></script>

  <!-- Mapillary JS -->
  <script src='https://unpkg.com/mapillary-js@4.1.2/dist/mapillary.js'></script>
  <link href='https://unpkg.com/mapillary-js@4.1.2/dist/mapillary.css' rel='stylesheet' />

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;font-family:'Inter',sans-serif;color:#1a1a1a;overflow:hidden}

    /* Main Layout */
    .app-container{display:flex;height:100vh;flex-direction:column}
    .content-container{display:flex;flex:1;overflow:hidden;position:relative}
    
    /* Map Panel */
    .map-panel{
      position:relative;flex:1;min-width:300px
    }
    #map{height:100%;width:100%}
    #mapCanvas{
      position:absolute;top:0;left:0;
      pointer-events:none;z-index:600
    }
    #mapCanvas.active{pointer-events:auto;cursor:crosshair}
    
    /* 3D View Container */
    #view3DContainer{
      position:absolute;top:0;left:0;width:100%;height:100%;
      display:none;background:#87CEEB
    }
    #view3DContainer.active{display:block}
    #mapbox3DContainer{
      width:100%;height:100%
    }
    #view3DCanvas{
      position:absolute;top:0;left:0;
      pointer-events:none;z-index:600
    }
    #view3DCanvas.active{pointer-events:auto;cursor:crosshair}

    /* PeakFinder Container */
    #peakFinderContainer{
      position:absolute;top:0;left:0;width:100%;height:100%;
      display:none;background:#87CEEB
    }
    #peakFinderContainer.active{display:block}
    #pfcanvas{
      width:100%;height:100%;display:block
    }
    #pfcanvasprogress{
      position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
      background:rgba(255,255,255,0.9);padding:2rem;border-radius:12px;
      box-shadow:0 8px 32px rgba(0,0,0,.2);z-index:10
    }
    .spinner{
      border:4px solid #f3f3f3;border-top:4px solid #9D2235;
      border-radius:50%;width:50px;height:50px;
      animation:spin 1s linear infinite;margin:0 auto
    }
    @keyframes spin{
      0%{transform:rotate(0deg)}
      100%{transform:rotate(360deg)}
    }

    /* Street View Container */
    #streetViewContainer{
      position:absolute;top:0;left:0;width:100%;height:100%;
      display:none;background:#000
    }
    #streetViewContainer.active{display:block}
    #streetViewPano{
      width:100%;height:100%
    }

    /* Mapillary Container */
    #mapillaryContainer{
      position:absolute;top:0;left:0;width:100%;height:100%;
      display:none;background:#000
    }
    #mapillaryContainer.active{display:block}
    #mapillaryViewer{
      width:100%;height:100%
    }

    /* Resizer */
    .resizer{
      width:6px;background:#e0e0e0;cursor:col-resize;
      position:relative;z-index:100;transition:background 0.2s;
      flex-shrink:0
    }
    .resizer:hover{background:#9D2235}
    .resizer:active{background:#C5283D}
    
    /* Prevent interactions during resize */
    body.resizing * {
      pointer-events:none!important
    }
    body.resizing .resizer {
      pointer-events:auto!important
    }

    /* Image Panel */
    .image-panel{
      position:relative;flex:1;min-width:300px;
      background:#f5f5f5;display:flex;flex-direction:column
    }
    .image-panel.hidden{display:none}

    /* Upload Section */
    .image-upload-section{
      background:#fff;padding:.8rem;border-bottom:2px solid #e0e0e0;
      flex-shrink:0
    }
    .image-upload-section .upload-btn{
      width:100%;padding:.7rem;background:linear-gradient(135deg,#9D2235,#C5283D);
      color:#fff;border:none;border-radius:8px;
      font-weight:600;cursor:pointer;transition:all 0.2s;
      font-size:.9rem;font-family:'Inter',sans-serif
    }
    .image-upload-section .upload-btn:hover{
      transform:translateY(-2px);box-shadow:0 4px 12px rgba(157,34,53,.3)
    }

    /* Layers Panel */
    .layers-panel{
      background:#fff;border-bottom:2px solid #e0e0e0;
      padding:.8rem;max-height:200px;overflow-y:auto;
      flex-shrink:0
    }
    .layers-panel h4{
      margin:0 0 .6rem;font-size:.9rem;font-weight:600;color:#333
    }
    .layers-list{
      display:flex;flex-direction:column;gap:.4rem
    }
    .no-layers{
      color:#999;font-size:.8rem;text-align:center;
      padding:.5rem;font-style:italic
    }
    .layer-item{
      background:#f8f9fa;border:2px solid #e0e0e0;
      border-radius:6px;padding:.5rem;
      display:flex;align-items:center;gap:.5rem;
      transition:all 0.2s;cursor:pointer
    }
    .layer-item:hover{
      border-color:#9D2235;background:#f0f4ff
    }
    .layer-item.active{
      border-color:#9D2235;background:#f0f4ff;
      box-shadow:0 2px 4px rgba(157,34,53,.2)
    }
    .layer-item .layer-preview{
      width:40px;height:40px;object-fit:cover;
      border-radius:4px;border:1px solid #ddd;
      flex-shrink:0
    }
    .layer-item .layer-info{
      flex:1;min-width:0
    }
    .layer-item .layer-name{
      font-size:.8rem;font-weight:500;color:#333;
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis
    }
    .layer-item .layer-controls{
      display:flex;gap:.3rem;align-items:center;flex-wrap:wrap
    }
    .layer-item input[type=range]{
      width:60px;height:4px;cursor:pointer
    }
    .layer-item .layer-control-row{
      display:flex;gap:.3rem;align-items:center;width:100%
    }
    .layer-item .control-label{
      font-size:.65rem;color:#666;min-width:35px
    }
    .layer-item .layer-btn{
      padding:.2rem .4rem;font-size:.7rem;
      border:1px solid #ddd;border-radius:4px;
      background:#fff;cursor:pointer;
      transition:all 0.2s
    }
    .layer-item .layer-btn:hover{
      background:#9D2235;color:#fff;border-color:#9D2235
    }
    .layer-visibility{
      font-size:.9rem;cursor:pointer;
      padding:.2rem .3rem;border-radius:3px;
      transition:all 0.2s
    }
    .layer-visibility:hover{
      background:#ddd
    }

    /* Image Viewer */
    .image-viewer{
      flex:1;position:relative;overflow:hidden;
      background:repeating-conic-gradient(#f0f0f0 0% 25%, #fff 0% 50%) 50% / 20px 20px
    }
    .image-canvas-container{
      position:absolute;top:0;left:0;width:100%;height:100%;
      display:block;
      overflow:hidden;
      cursor:grab;
      transition: all 0.2s ease;
    }
    .image-canvas-container.panning{cursor:grabbing}
    .image-canvas-container.drag-over{
      background: rgba(0, 123, 255, 0.1);
      border: 2px dashed #007bff;
      cursor: copy;
    }
    .image-canvas-container.drag-over::before{
      content: "Drop images here";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 123, 255, 0.9);
      color: white;
      padding: 1rem 2rem;
      border-radius: 8px;
      font-weight: bold;
      z-index: 1000;
      pointer-events: none;
    }
    .image-canvas-container canvas{
      display:block;
      width:100%;
      height:100%;
      transform-origin:center center;
      transition:transform 0.1s ease-out
    }
    #imageCanvas{
      cursor:crosshair
    }
    #imageCanvas.pan-cursor{cursor:grab}
    #imageCanvas.pan-cursor:active{cursor:grabbing}
    .no-image{
      display:flex;flex-direction:column;align-items:center;
      justify-content:center;height:100%;color:#999;gap:1rem
    }
    .no-image svg{width:80px;height:80px;opacity:.3}

    /* Toolbar */
    .toolbar{
      background:#fff;padding:.8rem 1rem;border-top:2px solid #e0e0e0;
      display:flex;gap:1rem;align-items:center;flex-wrap:wrap;
      flex-shrink:0;box-shadow:0 -2px 10px rgba(0,0,0,.05)
    }
    .toolbar-section{
      display:flex;gap:.5rem;align-items:center;
      padding-right:1rem;border-right:1px solid #e0e0e0
    }
    .toolbar-section:last-child{border-right:none}
    .toolbar-label{font-size:.75rem;font-weight:600;color:#666;text-transform:uppercase}
    
    .tool-btn{
      padding:.5rem .8rem;border:2px solid #ddd;
      border-radius:6px;background:#fff;cursor:pointer;
      font-size:.85rem;transition:all 0.2s;
      display:flex;align-items:center;gap:.3rem;
      font-family:'Inter',sans-serif
    }
    .tool-btn:hover{border-color:#9D2235;background:#f0f4ff}
    .tool-btn.active{
      background:linear-gradient(135deg,#9D2235,#C5283D);
      color:#fff;border-color:#9D2235
    }

    .color-btn{
      width:32px;height:32px;border-radius:6px;
      border:2px solid #ddd;cursor:pointer;
      transition:all 0.2s;position:relative
    }
    .color-btn:hover{transform:scale(1.1)}
    .color-btn.active{
      border:3px solid #000;box-shadow:0 0 0 2px #fff, 0 0 0 4px #000
    }

    .style-toggle{
      padding:.4rem .7rem;border:2px solid #ddd;
      border-radius:6px;background:#fff;cursor:pointer;
      font-size:.75rem;transition:all 0.2s;
      font-family:'Inter',sans-serif
    }
    .style-toggle.active{background:#333;color:#fff;border-color:#333}

    /* Sidebar Controls */
    .sidebar{
      position:absolute;top:1rem;left:1rem;z-index:1000;
      background:#fff;border-radius:12px;padding:1.2rem;
      box-shadow:0 8px 32px rgba(0,0,0,.15);
      width:350px;max-height:calc(100vh - 2rem);
      overflow-y:auto;transition:opacity 0.3s ease
    }
    .sidebar.collapsed{display:none}
    .sidebar h2{
      margin:0 0 1rem;font-size:1.2rem;font-weight:700;
      background:linear-gradient(135deg,#9D2235,#C5283D);
      -webkit-background-clip:text;-webkit-text-fill-color:transparent;
      background-clip:text;display:flex;align-items:center;
      justify-content:space-between
    }
    .collapse-btn{
      background:linear-gradient(135deg,#9D2235,#C5283D);
      color:#fff;border:none;border-radius:6px;
      width:28px;height:28px;cursor:pointer;
      font-size:1rem;display:flex;align-items:center;
      justify-content:center;transition:transform 0.2s;
      flex-shrink:0
    }
    .collapse-btn:hover{transform:scale(1.1)}
    .help-btn{
      background:linear-gradient(135deg,#4CAF50,#66BB6A);
      color:#fff;border:none;border-radius:6px;
      width:28px;height:28px;cursor:pointer;
      font-size:1.1rem;font-weight:bold;display:flex;align-items:center;
      justify-content:center;transition:transform 0.2s;
      flex-shrink:0;text-shadow:0 1px 2px rgba(0,0,0,0.3)
    }
    .help-btn:hover{transform:scale(1.1)}
    .sidebar label{font-size:.85rem;font-weight:600;display:block;margin-bottom:.3rem}
    .sidebar input[type=range], #fovSlider{
      width:100%;height:5px;border-radius:3px;
      background:linear-gradient(to right,#9D2235,#C5283D);
      outline:none;appearance:none;-webkit-appearance:none;cursor:pointer
    }
    .sidebar input[type=range]::-webkit-slider-thumb, #fovSlider::-webkit-slider-thumb{
      -webkit-appearance:none;width:16px;height:16px;
      border-radius:50%;background:#fff;
      box-shadow:0 2px 6px rgba(0,0,0,.2);cursor:pointer
    }
    .sidebar input[type=range]::-moz-range-thumb, #fovSlider::-moz-range-thumb{
      width:16px;height:16px;border-radius:50%;
      background:#fff;box-shadow:0 2px 6px rgba(0,0,0,.2);
      border:none;cursor:pointer
    }
    .sidebar p{font-size:.8rem;color:#666;margin:.6rem 0}
    #status{
      font-size:.8rem;color:#9D2235;margin-top:.5rem;
      font-weight:500;padding:.4rem;background:#f0f4ff;
      border-radius:6px;text-align:center
    }

    /* Filter Section */
    .filter-section{
      margin-top:1rem;border-top:2px solid #f0f0f0;
      padding-top:1rem
    }
    .filter-section h3{
      margin:0 0 .6rem;font-size:1rem;font-weight:600;
      display:flex;align-items:center;justify-content:space-between
    }
    .filter-controls{
      display:flex;gap:.4rem;margin-bottom:.6rem
    }
    .filter-btn{
      flex:1;padding:.4rem .6rem;font-size:.7rem;
      border:1px solid #ddd;border-radius:6px;
      background:#fff;cursor:pointer;font-weight:500;
      transition:all 0.2s;font-family:'Inter',sans-serif
    }
    .filter-btn:hover{background:#f5f5f5;border-color:#9D2235}
    
    .filter-grid{
      display:grid;grid-template-columns:1fr 1fr;
      gap:.5rem;max-height:250px;overflow-y:auto;
      padding:.4rem;background:#fafafa;border-radius:8px
    }
    .filter-item{
      display:flex;align-items:center;gap:.4rem;
      padding:.4rem;border-radius:6px;background:#fff;
      border:1px solid #e0e0e0;cursor:pointer;
      transition:all 0.2s
    }
    .filter-item:hover{border-color:#9D2235;box-shadow:0 2px 4px rgba(157,34,53,.1)}
    .filter-item input[type=checkbox]{
      width:14px;height:14px;cursor:pointer;
      accent-color:#9D2235
    }
    .filter-item label{
      margin:0;font-size:.75rem;cursor:pointer;
      flex:1;font-weight:500;color:#555
    }
    .filter-item.checked{
      background:linear-gradient(135deg,#9D223515,#C5283D15);
      border-color:#9D2235
    }
    
    /* Hierarchical Filter Categories */
    .filter-category{
      margin-bottom:.8rem;border:1px solid #e0e0e0;
      border-radius:8px;background:#fff;overflow:hidden
    }
    .category-header{
      display:flex;align-items:center;gap:.5rem;
      padding:.6rem .8rem;background:#f8f9fa;border-bottom:1px solid #e0e0e0;
      transition:background 0.2s ease;font-weight:500
    }
    .category-header:hover{background:#e9ecef}
    .category-checkbox{
      width:14px;height:14px;cursor:pointer;accent-color:#9D2235;
      flex-shrink:0
    }
    .category-name{font-size:.9rem;color:#495057;cursor:pointer;flex:1}
    .category-count{font-size:.75rem;color:#6c757d}
    .category-toggle{font-size:.8rem;color:#6c757d;transition:transform 0.2s ease;cursor:pointer}
    .category-items{
      padding:.4rem;display:grid;grid-template-columns:1fr;
      gap:.4rem;background:#fff
    }

    /* Summary Panel */
    .summary-panel{
      position:absolute;top:1rem;right:1rem;z-index:1000;
      background:#fff;border-radius:12px;padding:1.2rem;
      box-shadow:0 8px 32px rgba(0,0,0,.15);
      width:300px;max-width:calc(100% - 2rem);
      max-height:calc(100vh - 2rem);
      overflow-y:auto;display:none;transition:opacity 0.3s ease
    }
    .summary-panel.visible{display:block}
    .summary-panel.collapsed{display:none!important}
    .summary-panel h3{
      margin:0 0 1rem;font-size:1.2rem;font-weight:700;
      color:#333;display:flex;align-items:center;
      justify-content:space-between
    }
    
    /* Toggle buttons for collapsed panels */
    .panel-toggle{
      position:absolute;z-index:999;
      background:linear-gradient(135deg,#9D2235,#C5283D);
      color:#fff;border:none;border-radius:8px;
      padding:.6rem .8rem;cursor:pointer;
      font-size:.85rem;font-weight:600;
      box-shadow:0 4px 12px rgba(0,0,0,.2);
      transition:all 0.2s;font-family:'Inter',sans-serif;
      display:none
    }
    .panel-toggle:hover{transform:translateY(-2px);box-shadow:0 6px 16px rgba(0,0,0,.3)}
    .panel-toggle.visible{display:block}
    .panel-toggle.left{top:1rem;left:1rem}
    .panel-toggle.right{top:1rem;right:1rem}
    
    /* View Toggle Button */
    .view-toggle-btn{
      position:absolute;top:1rem;right:1rem;z-index:1000;
      background:linear-gradient(135deg,#9D2235,#C5283D);
      color:#fff;border:none;border-radius:8px;
      padding:.6rem 1rem;cursor:pointer;font-size:.85rem;
      font-weight:600;box-shadow:0 4px 12px rgba(0,0,0,.2);
      transition:all 0.2s;font-family:'Inter',sans-serif;
      display:flex;align-items:center;gap:.5rem
    }
    .view-toggle-btn:hover{
      transform:translateY(-2px);box-shadow:0 6px 16px rgba(0,0,0,.3)
    }

    /* Street View Buttons */
    .street-view-controls{
      position:absolute;top:5rem;right:1rem;z-index:1000;
      display:none;flex-direction:column;gap:.5rem
    }
    .street-view-controls.visible{display:flex}
    .street-view-btn{
      background:rgba(255,255,255,0.95);
      border:2px solid #9D2235;
      border-radius:8px;padding:.6rem 1rem;
      cursor:pointer;font-size:.85rem;font-weight:600;
      transition:all 0.2s;font-family:'Inter',sans-serif;
      color:#333
    }
    .street-view-btn:hover{
      background:#9D2235;color:#fff
    }
    .street-view-btn.active{
      background:#9D2235;color:#fff
    }
    .view-info-bar{
      position:absolute;bottom:1rem;left:50%;transform:translateX(-50%);
      z-index:999;background:rgba(255,255,255,0.95);
      border-radius:8px;padding:.6rem 1.2rem;
      box-shadow:0 4px 12px rgba(0,0,0,.2);
      font-size:.85rem;color:#333;display:none
    }
    .view-info-bar.visible{display:block}
    .view-info-bar .info-item{
      display:inline-block;margin:0 .8rem;
      font-weight:600;color:#9D2235
    }
    .summary-stats{
      display:grid;grid-template-columns:1fr 1fr;gap:.6rem;
      margin-bottom:1rem
    }
    .stat-card{
      padding:.8rem;background:linear-gradient(135deg,#9D2235,#C5283D);
      border-radius:10px;color:#fff;text-align:center
    }
    .stat-card .number{font-size:1.8rem;font-weight:700;margin-bottom:.2rem}
    .stat-card .label{font-size:.7rem;opacity:.9;text-transform:uppercase;letter-spacing:.5px}
    
    .category-breakdown{
      border-top:2px solid #f0f0f0;padding-top:1rem
    }
    .category-breakdown h4{
      margin:0 0 .6rem;font-size:.95rem;font-weight:600;color:#555
    }
    .category-item{
      margin-bottom:.5rem;
      background:#f8f9fa;border-radius:6px;
      border-left:3px solid #9D2235;
      overflow:hidden
    }
    .category-header{
      display:flex;justify-content:space-between;align-items:center;
      padding:.5rem .6rem;cursor:pointer;
      transition:background 0.2s
    }
    .category-header:hover{background:#e9ecef}
    .category-header .name{font-size:.8rem;font-weight:500;color:#333;flex:1}
    .category-header .count{
      font-size:.85rem;font-weight:700;color:#9D2235;
      background:#fff;padding:.15rem .5rem;border-radius:5px;
      margin-right:.5rem
    }
    .category-header .toggle-icon{
      font-size:.9rem;color:#9D2235;transition:transform 0.3s
    }
    .category-header .toggle-icon.expanded{transform:rotate(180deg)}
    .category-places{
      max-height:0;overflow:hidden;
      transition:max-height 0.3s ease-out;
      background:#fff;border-top:1px solid #e0e0e0
    }
    .category-places.expanded{max-height:300px;overflow-y:auto}
    .place-item{
      padding:.4rem .8rem;border-bottom:1px solid #f0f0f0;
      cursor:pointer;transition:all 0.2s;font-size:.75rem;
      display:flex;align-items:center;gap:.4rem
    }
    .place-item:hover{background:#f0f4ff;border-left:3px solid #9D2235;padding-left:1rem}
    .place-item:last-child{border-bottom:none}
    .place-item .icon{color:#9D2235;font-size:.7rem}
    .place-item .text{color:#555;flex:1}

    .mode-toggle-section{
      margin-top:1rem;padding-top:1rem;
      border-top:2px solid #f0f0f0
    }
    
    .mode-buttons{
      display:grid;grid-template-columns:1fr 1fr;gap:.5rem
    }
    
    .mode-btn{
      padding:.7rem;border:2px solid #ddd;
      background:#fff;border-radius:6px;cursor:pointer;
      font-weight:500;transition:all 0.2s;font-size:.85rem;
      font-family:'Inter',sans-serif
    }
    .mode-btn:hover{border-color:#9D2235}
    .mode-btn.active{
      background:linear-gradient(135deg,#9D2235,#C5283D);
      color:#fff;border-color:#9D2235
    }

    .layer-toggle{
      margin-top:1rem;padding-top:1rem;
      border-top:2px solid #f0f0f0
    }
    .toggle-btn{
      width:100%;padding:.6rem;border:2px solid #ddd;
      background:#fff;border-radius:6px;cursor:pointer;
      font-weight:500;transition:all 0.2s;font-size:.85rem;
      font-family:'Inter',sans-serif
    }
    .toggle-btn:hover{border-color:#9D2235}
    .toggle-btn.active{
      background:linear-gradient(135deg,#9D2235,#C5283D);
      color:#fff;border-color:#9D2235
    }

    /* Custom popup styling */
    .leaflet-popup-content{min-width:250px}
    .popup-title{
      font-size:1.05rem;font-weight:700;color:#333;
      margin:0 0 .5rem;padding-bottom:.5rem;
      border-bottom:2px solid #9D2235
    }
    .popup-category{
      font-size:.8rem;color:#9D2235;margin-bottom:.5rem;
      font-weight:500;font-style:italic
    }
    .popup-tags{
      background:#f8f9fa;padding:.5rem;border-radius:6px;
      margin:.5rem 0;font-size:.7rem;color:#666;
      max-height:80px;overflow-y:auto
    }
    .popup-tag{
      display:inline-block;margin:.15rem;padding:.15rem .4rem;
      background:#fff;border-radius:4px;border:1px solid #ddd;
      font-size:.65rem
    }
    .popup-link{
      display:inline-block;margin-top:.5rem;padding:.5rem .8rem;
      background:linear-gradient(135deg,#9D2235,#C5283D);
      color:#fff;text-decoration:none;border-radius:6px;
      font-weight:600;font-size:.8rem;text-align:center;
      width:100%;transition:transform 0.2s
    }
    .popup-link:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(157,34,53,.3)}

    /* Marker clusters */
    .marker-cluster-small{background:rgba(157,34,53,.6)!important}
    .marker-cluster-small div{background:rgba(157,34,53,.8)!important;color:#fff!important;font-weight:700}
    .marker-cluster-medium{background:rgba(197,40,61,.6)!important}
    .marker-cluster-medium div{background:rgba(197,40,61,.8)!important;color:#fff!important;font-weight:700}
    .marker-cluster-large{background:rgba(157,34,53,.8)!important}
    .marker-cluster-large div{background:rgba(197,40,61,1)!important;color:#fff!important;font-weight:700}

    /* Scrollbar */
    ::-webkit-scrollbar{width:8px;height:8px}
    ::-webkit-scrollbar-track{background:#f1f1f1;border-radius:4px}
    ::-webkit-scrollbar-thumb{background:#9D2235;border-radius:4px}
    ::-webkit-scrollbar-thumb:hover{background:#C5283D}

    /* Geocoder customization */
    .leaflet-control-geocoder{
      box-shadow:0 4px 12px rgba(0,0,0,.15)!important;
      border-radius:8px!important
    }

    /* Help Overlay */
    .help-overlay{
      position:fixed;top:0;left:0;width:100%;height:100%;
      background:rgba(0,0,0,0.8);z-index:2000;
      display:none;align-items:center;justify-content:center;
      padding:2rem;box-sizing:border-box
    }
    .help-overlay.visible{display:flex}
    .help-content{
      background:#fff;border-radius:16px;padding:2rem;
      max-width:800px;max-height:90vh;overflow-y:auto;
      box-shadow:0 20px 60px rgba(0,0,0,0.3);
      position:relative
    }
    .help-header{
      display:flex;justify-content:space-between;
      align-items:center;margin-bottom:1.5rem;
      padding-bottom:1rem;border-bottom:2px solid #e0e0e0
    }
    .help-title{
      font-size:1.5rem;font-weight:700;
      background:linear-gradient(135deg,#9D2235,#C5283D);
      -webkit-background-clip:text;-webkit-text-fill-color:transparent;
      background-clip:text;margin:0
    }
    .help-close{
      background:#f44336;color:#fff;border:none;
      border-radius:50%;width:32px;height:32px;
      cursor:pointer;font-size:1.2rem;
      display:flex;align-items:center;justify-content:center;
      transition:transform 0.2s
    }
    .help-close:hover{transform:scale(1.1)}
    .help-section{
      margin-bottom:1.5rem
    }
    .help-section h3{
      font-size:1.1rem;font-weight:600;color:#333;
      margin:0 0 0.8rem;display:flex;align-items:center;gap:0.5rem
    }
    .help-section p{
      font-size:0.9rem;color:#666;line-height:1.6;
      margin:0 0 0.8rem
    }
    .help-section ul{
      font-size:0.9rem;color:#666;line-height:1.6;
      margin:0 0 0.8rem;padding-left:1.2rem
    }
    .help-section li{
      margin-bottom:0.4rem
    }
    .help-feature{
      background:#f8f9fa;border-left:4px solid #9D2235;
      padding:0.8rem;margin:0.8rem 0;border-radius:0 6px 6px 0
    }
    .help-feature strong{
      color:#9D2235;font-weight:600
    }

    /* Sticky Notes */
    .sticky-note{
      position:absolute;
      background:#ffd700;
      background:linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
      padding:12px;
      border-radius:4px;
      box-shadow:0 4px 12px rgba(0,0,0,0.25);
      min-width:180px;
      max-width:250px;
      font-family:'Comic Sans MS', cursive, sans-serif;
      cursor:move;
      z-index:1500;
      user-select:none;
    }
    .sticky-note.dragging{
      opacity:0.8;
      box-shadow:0 8px 20px rgba(0,0,0,0.35);
    }
    .sticky-note-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:8px;
      padding-bottom:4px;
      border-bottom:1px dashed rgba(0,0,0,0.2);
    }
    .sticky-note-drag-handle{
      font-size:10px;
      color:rgba(0,0,0,0.4);
      cursor:move;
    }
    .sticky-note-delete{
      background:#d32f2f;
      color:#fff;
      border:none;
      border-radius:3px;
      width:20px;
      height:20px;
      cursor:pointer;
      font-size:12px;
      display:flex;
      align-items:center;
      justify-content:center;
      transition:all 0.2s;
      line-height:1;
    }
    .sticky-note-delete:hover{
      background:#b71c1c;
      transform:scale(1.1);
    }
    .sticky-note-textarea{
      width:100%;
      min-height:80px;
      background:transparent;
      border:none;
      resize:vertical;
      font-family:'Comic Sans MS', cursive, sans-serif;
      font-size:13px;
      color:#333;
      outline:none;
      cursor:text;
    }
    .sticky-note-textarea::placeholder{
      color:rgba(0,0,0,0.4);
    }
  </style>
</head>
<body>
  <div class="app-container">
    <div class="content-container">
      <!-- Map Panel -->
      <div class="map-panel">
        <div id="map"></div>
        <canvas id="mapCanvas"></canvas>
        
        <!-- 3D View Container -->
        <div id="view3DContainer">
          <div id="mapbox3DContainer"></div>
          <canvas id="view3DCanvas"></canvas>
        </div>
        
        <!-- PeakFinder Container -->
        <div id="peakFinderContainer">
          <canvas id="pfcanvas" oncontextmenu="event.preventDefault()"></canvas>
          <div id="pfcanvasprogress">
            <div class="spinner"></div>
            <p style="margin-top:1rem;text-align:center;color:#333">Loading PeakFinder...</p>
          </div>
        </div>
        
        <!-- Street View Container -->
        <div id="streetViewContainer">
          <iframe id="streetViewPano" frameborder="0" style="border:0" allowfullscreen></iframe>
        </div>
        
        <!-- Mapillary Container -->
        <div id="mapillaryContainer">
          <div id="mapillaryViewer"></div>
        </div>
        
        <!-- View Toggle Button -->
        <button class="view-toggle-btn" id="viewToggleBtn" onclick="toggleMapView()" style="display:none">
          <span id="viewToggleIcon">🗺️</span>
          <span id="viewToggleText">Back to 2D Map</span>
        </button>
        
        <!-- Street View Controls -->
        <div class="street-view-controls" id="streetViewControls">
          <button class="street-view-btn" onclick="showStreetView()">🔍 Google Street View</button>
          <button class="street-view-btn" onclick="showMapillary()">📷 Mapillary</button>
          <button class="street-view-btn" onclick="backToMap()">🗺️ Back to Map</button>
        </div>
        
        <!-- Info Bar for 3D View -->
        <div class="view-info-bar" id="viewInfoBar">
          <span class="info-item"><span id="view3DDistance">0 km</span></span>
          <span class="info-item"><span id="view3DBearing">0°</span></span>
        </div>
        
        <!-- Toggle buttons for collapsed panels -->
        <button class="panel-toggle left" id="sidebarToggle" onclick="toggleSidebar()">
          🔍 Show Geolocator
        </button>
        <button class="panel-toggle right" id="summaryToggle" onclick="toggleSummary()">
          📊 Show Summary
        </button>

        <div class="sidebar" id="sidebar">
          <h2>
            <span>🔍 Geolocator</span>
            <div style="display:flex;gap:4px">
              <button class="help-btn" onclick="showHelp()" title="Show help">?</button>
              <button class="collapse-btn" onclick="toggleSidebar()" title="Collapse panel">◀</button>
            </div>
          </h2>
          
          <div class="mode-toggle-section">
            <label>Map Mode</label>
            <div class="mode-buttons" style="grid-template-columns:1fr 1fr 1fr;grid-template-rows:1fr 1fr">
              <button class="mode-btn active" id="placesMode" onclick="setMapMode('places')">📍 Search</button>
              <button class="mode-btn" id="groundMode" onclick="setMapMode('ground')">📷 Ground</button>
              <button class="mode-btn" id="drawMode" onclick="setMapMode('draw')">✏️ Draw</button>
              <button class="mode-btn" id="losMode" onclick="setMapMode('los')">📊 LOS</button>
              <button class="mode-btn" id="anglesMode" onclick="setMapMode('angles')">📐 Angles</button>
            </div>
          </div>

          <div id="placesControls">
            <label for="radiusSlider" style="margin-top:1rem">
              Search Radius: <span id="radiusLabel">500</span> m
            </label>
            <input id="radiusSlider" type="range" min="100" max="5000" step="100" value="500"/>
            <p>Click the map to discover nearby places</p>
            
            <div class="filter-section">
              <h3>
                <span>Filter Categories</span>
                <span style="font-size:.7rem;color:#999" id="filterCount">(24/24)</span>
              </h3>
              <div class="filter-controls">
                <button class="filter-btn" onclick="selectAllFilters()">Select All</button>
                <button class="filter-btn" onclick="deselectAllFilters()">Clear All</button>
              </div>
              <div class="filter-grid" id="filterGrid"></div>
            </div>
          </div>

          <div id="groundControls" style="display:none">
            <p style="margin-top:1rem">Click the map to select a location for ground-level imagery</p>
            
            <div style="margin-top:1rem;padding:1rem;background:#f8f9fa;border-radius:8px;border-left:3px solid #9D2235">
              <p style="font-size:.85rem;margin-bottom:.5rem;font-weight:600">Available Views:</p>
              <ul style="font-size:.8rem;color:#666;line-height:1.5;padding-left:1.2rem">
                <li><strong>Google Street View:</strong> 360° panoramas from Google</li>
                <li><strong>Mapillary:</strong> Community-contributed street photos</li>
              </ul>
              <p style="font-size:.75rem;color:#999;margin-top:.5rem;font-style:italic">
                Note: Coverage varies by location. Try both sources for best results.
              </p>
            </div>
          </div>

          <div id="anglesControls" style="display:none">
            <p style="margin-top:1rem">Draw a polygon area to analyze road intersections</p>
            
            <fieldset style="margin-top:.8rem;border:1px solid #e0e0e0;border-radius:6px;padding:.8rem">
              <legend style="font-weight:600;font-size:.85rem;padding:0 .4rem">Angle Mode</legend>
              <label style="display:flex;align-items:center;gap:.5rem;margin:.3rem 0">
                <input type="radio" name="angleMode" value="90" checked onchange="updateAngleMode()">
                <span style="font-size:.85rem">Normalized (≤90°)</span>
              </label>
              <label style="display:flex;align-items:center;gap:.5rem;margin:.3rem 0">
                <input type="radio" name="angleMode" value="180" onchange="updateAngleMode()">
                <span style="font-size:.85rem">Full (≤180°)</span>
              </label>
            </fieldset>

            <label style="margin-top:1rem">
              Angle Range (degrees):
              <div style="display:flex;gap:.5rem;align-items:center;margin-top:.3rem">
                <input id="minAngle" type="number" value="80" step="1" min="0" 
                       style="width:70px;padding:.4rem;border:1px solid #ddd;border-radius:4px;font-size:.85rem">
                <span>—</span>
                <input id="maxAngle" type="number" value="100" step="1" min="0" 
                       style="width:70px;padding:.4rem;border:1px solid #ddd;border-radius:4px;font-size:.85rem">
              </div>
              <small id="rangeHint" style="color:#666;display:block;margin-top:.3rem;font-size:.75rem">Allowed: 0—90°</small>
            </label>

            <details style="margin-top:1rem;border:1px solid #e0e0e0;border-radius:6px;padding:.8rem">
              <summary style="cursor:pointer;font-weight:600;font-size:.85rem">Highway Filter</summary>
              <div style="display:grid;grid-template-columns:1fr 1fr;gap:.5rem;margin-top:.8rem">
                <label style="display:flex;align-items:center;gap:.3rem;font-size:.75rem">
                  <input type="checkbox" class="hwy" value="motorway" checked> motorway
                </label>
                <label style="display:flex;align-items:center;gap:.3rem;font-size:.75rem">
                  <input type="checkbox" class="hwy" value="trunk" checked> trunk
                </label>
                <label style="display:flex;align-items:center;gap:.3rem;font-size:.75rem">
                  <input type="checkbox" class="hwy" value="primary" checked> primary
                </label>
                <label style="display:flex;align-items:center;gap:.3rem;font-size:.75rem">
                  <input type="checkbox" class="hwy" value="secondary" checked> secondary
                </label>
                <label style="display:flex;align-items:center;gap:.3rem;font-size:.75rem">
                  <input type="checkbox" class="hwy" value="tertiary" checked> tertiary
                </label>
                <label style="display:flex;align-items:center;gap:.3rem;font-size:.75rem">
                  <input type="checkbox" class="hwy" value="unclassified" checked> unclassified
                </label>
                <label style="display:flex;align-items:center;gap:.3rem;font-size:.75rem">
                  <input type="checkbox" class="hwy" value="residential" checked> residential
                </label>
                <label style="display:flex;align-items:center;gap:.3rem;font-size:.75rem">
                  <input type="checkbox" class="hwy" value="service" checked> service
                </label>
              </div>
            </details>

            <label style="display:flex;align-items:center;gap:.5rem;margin-top:1rem;font-size:.85rem">
              <input id="showAllRoads" type="checkbox"> 
              <span>Show all roads (context)</span>
            </label>

            <div style="display:grid;grid-template-columns:1fr;gap:.5rem;margin-top:1rem">
              <button class="filter-btn" onclick="fetchAnglesData()" 
                      style="padding:.7rem;font-size:.85rem;font-weight:600">
                🔍 Fetch & Filter
              </button>
              <button class="filter-btn" onclick="downloadIntersections()" 
                      style="padding:.5rem;font-size:.8rem">
                📥 Download Intersections
              </button>
              <button class="filter-btn" onclick="downloadSegments()" 
                      style="padding:.5rem;font-size:.8rem">
                📥 Download Segments
              </button>
            </div>

            <div style="margin-top:1rem;padding:1rem;background:#f8f9fa;border-radius:8px;border-left:3px solid #9D2235">
              <p style="font-size:.85rem;margin-bottom:.5rem;font-weight:600">How to use:</p>
              <ol style="font-size:.8rem;color:#666;line-height:1.5;padding-left:1.2rem">
                <li>Use the draw tool (top-right) to create a polygon</li>
                <li>Adjust angle range and highway filters</li>
                <li>Click "Fetch & Filter"</li>
                <li>Red lines show matching road segments</li>
                <li>Blue dots show intersection points</li>
              </ol>
            </div>
          </div>

          <div id="losControls" style="display:none">
            <div style="margin-top:1rem">
              <label>Visualization Mode</label>
              <div style="display:grid;grid-template-columns:1fr 1fr;gap:.5rem;margin-top:.5rem">
                <button class="mode-btn active" id="mapboxLOSMode" onclick="setLOSMode('mapbox')">
                  🗻 Mapbox 3D
                </button>
                <button class="mode-btn" id="peakfinderLOSMode" onclick="setLOSMode('peakfinder')">
                  ⛰️ PeakFinder
                </button>
              </div>
            </div>
            
            <div style="margin-top:1rem">
              <label>Mapbox Access Token 
                <a href="https://account.mapbox.com/access-tokens/" target="_blank" rel="noopener" 
                   style="color:#9D2235;text-decoration:none;font-size:1rem" title="Get your free Mapbox token">ℹ</a>
              </label>
              <input type="text" id="mapboxToken" placeholder="pk.eyJ..." 
                     style="width:100%;padding:.5rem;border:2px solid #ddd;border-radius:6px;font-size:.85rem;margin-top:.3rem"
                     onchange="saveMapboxToken()"/>
              <p style="font-size:.7rem;color:#666;margin-top:.3rem">
                Required for Mapbox 3D mode. Free tier: 100k requests/month.
              </p>
            </div>
            
            <div style="margin-top:1rem;padding:1rem;background:#f8f9fa;border-radius:8px;border-left:3px solid #9D2235">
              <p style="font-size:.85rem;margin-bottom:.5rem;font-weight:600">How to use:</p>
              <ol style="font-size:.8rem;color:#666;line-height:1.5;padding-left:1.2rem">
                <li>Choose visualization mode above</li>
                <li>Enter Mapbox token (for 3D mode only)</li>
                <li>Click Point A (observer position)</li>
                <li>Click Point B (what you're looking at)</li>
                <li>View panoramic horizon or 3D terrain</li>
              </ol>
            </div>
            
            <div id="losStatus" style="margin-top:1rem;padding:.6rem;background:#f0f4ff;border-radius:6px;text-align:center;font-size:.85rem;color:#9D2235">
              Choose mode and click two points
            </div>

            <button class="filter-btn" onclick="clearLineOfSight()" style="margin-top:1rem;width:100%">
              Clear Points
            </button>
          </div>
          
          <div id="status">Ready</div>

          <div class="layer-toggle">
            <label>Map Layer</label>
            <div style="display:grid;gap:.5rem">
              <button class="toggle-btn active" id="layerStreet" onclick="setMapLayer('street')">
                🗺️ Street Map
              </button>
              <button class="toggle-btn" id="layerSatellite" onclick="setMapLayer('satellite')">
                🛰️ ESRI Satellite
              </button>
              <button class="toggle-btn" id="layerGoogle" onclick="setMapLayer('google')">
                🌍 Google Satellite
              </button>
              <button class="toggle-btn" id="elevationToggle" onclick="toggleElevationOverlay()">
                ⛰️ Elevation Overlay (Mapbox)
              </button>
              <div id="elevationOpacityControl" style="display:none">
                <label for="elevationOpacity" style="font-size:.75rem;color:#666">Opacity</label>
                <input id="elevationOpacity" type="range" min="0" max="100" value="60" oninput="setElevationOpacity(this.value)" />
                <label for="elevationEnhance" style="font-size:.75rem;color:#666;margin-top:.4rem;display:block">Enhance lines</label>
                <input id="elevationEnhance" type="range" min="100" max="220" value="135" oninput="setElevationEnhance(this.value)" />
                <label for="elevationBlend" style="font-size:.75rem;color:#666;margin-top:.4rem;display:block">Blend</label>
                <select id="elevationBlend" onchange="setElevationBlend(this.value)">
                  <option value="multiply">Multiply (best on light maps)</option>
                  <option value="screen">Screen (best on dark/satellite)</option>
                  <option value="overlay">Overlay</option>
                  <option value="normal">Normal</option>
                </select>
              </div>
            </div>
            <p style="font-size:.7rem;color:#999;margin-top:.5rem;line-height:1.3">
              Note: Google layer works but may require API key for production use
            </p>
          </div>
        </div>

        <!-- Summary Panel -->
        <div class="summary-panel" id="summaryPanel">
          <h3>
            <span>📊 Discovery Summary</span>
            <button class="collapse-btn" onclick="toggleSummary()" title="Collapse panel">▶</button>
          </h3>
          <div class="summary-stats">
            <div class="stat-card">
              <div class="number" id="totalPlaces">0</div>
              <div class="label">Total Places</div>
            </div>
            <div class="stat-card" style="background:linear-gradient(135deg,#C5283D,#E84A5F)">
              <div class="number" id="totalCategories">0</div>
              <div class="label">Categories</div>
            </div>
          </div>
          <div class="category-breakdown">
            <h4>Breakdown by Category</h4>
            <div id="categoryList"></div>
          </div>
        </div>
      </div>

      <!-- Resizer -->
      <div class="resizer" id="resizer"></div>

      <!-- Image Panel -->
      <div class="image-panel" id="imagePanel">
        <!-- Upload Section -->
        <div class="image-upload-section">
          <input type="file" id="imageUpload" accept="image/*" multiple style="display:none"/>
          <button class="upload-btn" onclick="document.getElementById('imageUpload').click()">
            🖼️ Upload Images
          </button>
        </div>
        
        <!-- Layers Panel -->
        <div class="layers-panel" id="layersPanel">
          <h4>Image Layers</h4>
          <div class="layers-list" id="layersList">
            <p class="no-layers">No images uploaded</p>
          </div>
        </div>
        
        <div class="image-viewer" id="imageViewer">
          <div class="no-image">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
              <circle cx="8.5" cy="8.5" r="1.5"/>
              <polyline points="21 15 16 10 5 21"/>
            </svg>
            <p>Upload images to begin analysis</p>
          </div>
          <div class="image-canvas-container">
            <canvas id="imageCanvas"></canvas>
          </div>
        </div>

        <!-- Drawing Toolbar -->
        <div class="toolbar">
          <div class="toolbar-section">
            <span class="toolbar-label">Tools</span>
            <button class="tool-btn" data-tool="pan" onclick="selectTool('pan')">✋ Pan</button>
            <button class="tool-btn" data-tool="rect" onclick="selectTool('rect')">▭ Rect</button>
            <button class="tool-btn" data-tool="circle" onclick="selectTool('circle')">⭕ Circle</button>
            <button class="tool-btn" data-tool="ellipse" onclick="selectTool('ellipse')">⬭ Ellipse</button>
            <button class="tool-btn" data-tool="line" onclick="selectTool('line')">─ Line</button>
            <button class="tool-btn" data-tool="arrow" onclick="selectTool('arrow')">➜ Arrow</button>
            <button class="tool-btn" data-tool="polygon" onclick="selectTool('polygon')">⬡ Poly</button>
            <button class="tool-btn" data-tool="freehand" onclick="selectTool('freehand')">✏ Draw</button>
            <button class="tool-btn" data-tool="note" onclick="selectTool('note')">📝 Note</button>
            <button class="tool-btn" onclick="addProtractorImage()">📐 Protractor</button>
          </div>

          <div class="toolbar-section">
            <span class="toolbar-label">Color</span>
            <input type="color" id="colorPicker" value="#FF4444" onchange="selectColor(this.value)" 
                   style="width:40px;height:32px;border:2px solid #ddd;border-radius:6px;cursor:pointer;background:none"/>
          </div>

          <div class="toolbar-section">
            <span class="toolbar-label">Style</span>
            <button class="style-toggle active" id="solidToggle" onclick="toggleLineStyle()">Solid</button>
            <button class="style-toggle" id="fillToggle" onclick="toggleFill()">Fill</button>
            <input type="range" id="opacitySlider" min="0" max="100" value="20" 
                   onchange="updateFillOpacity(this.value)" 
                   oninput="updateFillOpacity(this.value)"
                   style="width:60px;height:4px;cursor:pointer;margin-left:8px"
                   title="Fill Opacity"/>
            <span id="opacityLabel" style="font-size:.7rem;color:#666;margin-left:4px">20%</span>
          </div>

          <div class="toolbar-section">
            <span class="toolbar-label">Width</span>
            <button class="style-toggle active" data-width="1" onclick="selectLineWidth(1)">1px</button>
            <button class="style-toggle" data-width="2" onclick="selectLineWidth(2)">2px</button>
            <button class="style-toggle" data-width="3" onclick="selectLineWidth(3)">3px</button>
            <button class="style-toggle" data-width="5" onclick="selectLineWidth(5)">5px</button>
          </div>

          <div class="toolbar-section">
            <button class="tool-btn" onclick="undoLast()">↶ Undo</button>
            <button class="tool-btn" onclick="clearAll()">🗑️ Clear</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Help Overlay -->
  <div class="help-overlay" id="helpOverlay">
    <div class="help-content">
      <div class="help-header">
        <h1 class="help-title">🔍 Geolocator Help</h1>
        <button class="help-close" onclick="hideHelp()">×</button>
      </div>
      
      <div class="help-section">
        <h3>🗺️ Getting Started</h3>
        <p>This tool helps you discover and analyze locations using multiple data sources and visualization modes.</p>
        
        <div class="help-feature">
          <strong>Quick Start:</strong> Click anywhere on the map to search for nearby places, or use the search bar in the top-right corner to find specific locations.
        </div>
      </div>

      <div class="help-section">
        <h3>📍 Search Mode</h3>
        <p>Discover places around any location:</p>
        <ul>
          <li><strong>Click the map</strong> to search for places within the selected radius</li>
          <li><strong>Adjust radius</strong> using the slider (100m to 5km)</li>
          <li><strong>Filter categories</strong> to focus on specific types of places</li>
          <li><strong>View results</strong> in the summary panel on the right</li>
        </ul>
      </div>

      <div class="help-section">
        <h3>📐 Angles Mode</h3>
        <p>Analyze road intersection angles for forensic purposes:</p>
        <ul>
          <li><strong>Draw a polygon</strong> using the drawing tools (top-right)</li>
          <li><strong>Select angle mode</strong>: Normalized (≤90°) or Full (≤180°)</li>
          <li><strong>Set angle range</strong> to filter specific intersection types</li>
          <li><strong>Filter highway types</strong> to focus on specific road categories</li>
          <li><strong>Click Fetch & Filter</strong> to find matching intersections</li>
          <li><strong>Download results</strong> as GeoJSON for further analysis</li>
        </ul>
      </div>

      <div class="help-section">
        <h3>📷 Ground View Mode</h3>
        <p>Explore street-level imagery:</p>
        <ul>
          <li><strong>Click the map</strong> to select a location</li>
          <li><strong>Choose Google Street View</strong> for 360° panoramas</li>
          <li><strong>Try Mapillary</strong> for community-contributed photos</li>
          <li><strong>Switch between sources</strong> for better coverage</li>
        </ul>
      </div>

      <div class="help-section">
        <h3>✏️ Drawing Tools</h3>
        <p>Annotate images and maps with professional drawing tools:</p>
        <ul>
          <li><strong>Pan Tool:</strong> Move around images and select layers</li>
          <li><strong>Shapes:</strong> Rectangle, circle, ellipse, line, arrow, polygon</li>
          <li><strong>Freehand:</strong> Draw custom shapes</li>
          <li><strong>Sticky Notes:</strong> Click to place draggable text notes anywhere</li>
          <li><strong>Color Picker:</strong> Choose any color from the full spectrum</li>
          <li><strong>Fill Control:</strong> Toggle fills on/off and adjust transparency</li>
          <li><strong>Line Style:</strong> Solid or dashed lines</li>
          <li><strong>Line Width:</strong> 1px to 5px thickness options</li>
        </ul>
        <div class="help-feature">
          <strong>Sticky Notes:</strong> Select the Note tool and click anywhere on the map or image to place a note. Click and drag the header to move notes. Type directly in the note area. Delete with the × button.
        </div>
      </div>

      <div class="help-section">
        <h3>📊 Line of Sight (LOS)</h3>
        <p>Analyze visibility between two points with two visualization options:</p>
        <ul>
          <li><strong>Choose mode:</strong> Mapbox 3D (requires token) or PeakFinder (no token needed)</li>
          <li><strong>Click Point A</strong> (observer position)</li>
          <li><strong>Click Point B</strong> (target location)</li>
          <li><strong>View terrain:</strong> 3D interactive view or labeled mountain panorama</li>
        </ul>
      </div>

      <div class="help-section">
        <h3>🖼️ Image Analysis</h3>
        <p>Upload and analyze images:</p>
        <ul>
          <li><strong>Upload images</strong> using the upload button</li>
          <li><strong>Layer management</strong> with opacity and scale controls</li>
          <li><strong>Pan and zoom</strong> for detailed analysis</li>
          <li><strong>Draw annotations</strong> directly on images</li>
        </ul>
      </div>

      <div class="help-section">
        <h3>🎛️ Map Layers</h3>
        <p>Switch between different map types:</p>
        <ul>
          <li><strong>Street Map:</strong> OpenStreetMap for navigation</li>
          <li><strong>ESRI Satellite:</strong> High-resolution satellite imagery</li>
          <li><strong>Google Satellite:</strong> Alternative satellite view</li>
        </ul>
      </div>

      <div class="help-section">
        <h3>💡 Tips & Tricks</h3>
        <ul>
          <li><strong>Resize panels</strong> by dragging the separator between map and image areas</li>
          <li><strong>Collapse panels</strong> using the arrow buttons to maximize workspace</li>
          <li><strong>Undo drawings</strong> with the undo button or clear all with the clear button</li>
          <li><strong>Rotate map</strong> using the compass control in the bottom-left</li>
          <li><strong>Zoom to places</strong> by clicking on them in the summary panel</li>
        </ul>
      </div>

      <div class="help-section">
        <h3>🔧 Keyboard Shortcuts</h3>
        <ul>
          <li><strong>Mouse wheel:</strong> Zoom in/out</li>
          <li><strong>Shift + Mouse wheel:</strong> Pan images</li>
          <li><strong>Double-click:</strong> Reset image zoom</li>
          <li><strong>Double-click:</strong> Complete polygon drawing</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
/* ========== MAP SETUP ========== */
const map = L.map('map', {
  center: [19.4326, -99.1332],
  zoom: 13,
  zoomControl: true,
  scrollWheelZoom: true,
  doubleClickZoom: true,
  boxZoom: true,
  keyboard: true,
  maxZoom: 20,
  minZoom: 2,
  rotate: true,
  bearing: 0,
  touchRotate: true
});

// Add Geoman drawing controls
map.pm.addControls({
  position: 'topright',
  drawCircle: false,
  drawMarker: false,
  drawCircleMarker: false,
  drawPolyline: false
});

L.Control.RotationControl = L.Control.extend({
  onAdd: function(map) {
    const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
    container.style.background = '#fff';
    container.style.borderRadius = '4px';
    container.style.padding = '5px';
    container.style.boxShadow = '0 2px 6px rgba(0,0,0,0.3)';
    
    const compass = L.DomUtil.create('div', '', container);
    compass.id = 'mapCompass';
    compass.style.cssText = 'width:50px;height:50px;position:relative;margin:5px';
    compass.innerHTML = `
      <svg width="50" height="50" viewBox="0 0 50 50" style="transform-origin:center;transition:transform 0.3s">
        <circle cx="25" cy="25" r="23" fill="#f0f0f0" stroke="#9D2235" stroke-width="2"/>
        <path d="M25 5 L25 45 M25 5 L21 9 M25 5 L29 9" stroke="#9D2235" stroke-width="2.5" fill="none"/>
        <text x="25" y="15" text-anchor="middle" fill="#9D2235" font-size="10" font-weight="bold">N</text>
        <text x="25" y="43" text-anchor="middle" fill="#666" font-size="8">S</text>
        <text x="8" y="28" text-anchor="middle" fill="#666" font-size="8">W</text>
        <text x="42" y="28" text-anchor="middle" fill="#666" font-size="8">E</text>
      </svg>
    `;
    
    const bearingDisplay = L.DomUtil.create('div', '', container);
    bearingDisplay.id = 'bearingDisplay';
    bearingDisplay.style.cssText = 'text-align:center;font-size:11px;font-weight:bold;color:#333;margin-bottom:5px';
    bearingDisplay.textContent = '0°';
    
    const helpText = L.DomUtil.create('div', '', container);
    helpText.style.cssText = 'text-align:center;font-size:9px;color:#888;margin-bottom:3px;line-height:1.2';
    helpText.innerHTML = 'Use buttons below<br/>to rotate map';
    
    const btnContainer = L.DomUtil.create('div', '', container);
    btnContainer.style.cssText = 'display:flex;gap:2px;margin-top:5px';
    
    const rotateLeftBtn = L.DomUtil.create('button', '', btnContainer);
    rotateLeftBtn.innerHTML = '↶';
    rotateLeftBtn.title = 'Rotate Left (5°)';
    rotateLeftBtn.style.cssText = 'flex:1;padding:5px;cursor:pointer;border:1px solid #ddd;background:#fff;border-radius:3px;font-size:16px';
    
    const resetBtn = L.DomUtil.create('button', '', btnContainer);
    resetBtn.innerHTML = '⬆';
    resetBtn.title = 'Reset to North (0°)';
    resetBtn.style.cssText = 'flex:1;padding:5px;cursor:pointer;border:1px solid #ddd;background:#fff;border-radius:3px;font-size:16px';
    
    const rotateRightBtn = L.DomUtil.create('button', '', btnContainer);
    rotateRightBtn.innerHTML = '↷';
    rotateRightBtn.title = 'Rotate Right (5°)';
    rotateRightBtn.style.cssText = 'flex:1;padding:5px;cursor:pointer;border:1px solid #ddd;background:#fff;border-radius:3px;font-size:16px';
    
    L.DomEvent.on(rotateLeftBtn, 'click', function(e) {
      L.DomEvent.stopPropagation(e);
      L.DomEvent.preventDefault(e);
      const currentBearing = map.getBearing() || 0;
      map.setBearing(currentBearing - 5);
    });
    
    L.DomEvent.on(resetBtn, 'click', function(e) {
      L.DomEvent.stopPropagation(e);
      L.DomEvent.preventDefault(e);
      map.setBearing(0);
    });
    
    L.DomEvent.on(rotateRightBtn, 'click', function(e) {
      L.DomEvent.stopPropagation(e);
      L.DomEvent.preventDefault(e);
      const currentBearing = map.getBearing() || 0;
      map.setBearing(currentBearing + 5);
    });
    
    function updateCompass() {
      const bearing = map.getBearing() || 0;
      const svg = compass.querySelector('svg');
      svg.style.transform = `rotate(${-bearing}deg)`;
      bearingDisplay.textContent = Math.round(bearing) + '°';
    }
    
    map.on('rotate', updateCompass);
    updateCompass();
    
    L.DomEvent.disableClickPropagation(container);
    return container;
  }
});

new L.Control.RotationControl({ position: 'bottomleft' }).addTo(map);

let currentLayer = 'street';
const streetLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors',
  maxZoom: 19
}).addTo(map);

const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: '&copy; Esri',
  maxZoom: 19
});

const googleSatelliteLayer = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
  attribution: '&copy; Google',
  maxZoom: 20
});

const labelsOverlay = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors, &copy; CARTO',
  subdomains: 'abcd',
  maxZoom: 20,
  opacity: 0.9
});

const geocoder = L.Control.geocoder({
  defaultMarkGeocode: false,
  position: 'topright',
  placeholder: 'Search location...',
  errorMessage: 'Nothing found.'
}).on('markgeocode', function(e) {
  const latlng = e.geocode.center;
  map.setView(latlng, 15);
  L.marker(latlng).addTo(map).bindPopup(e.geocode.name).openPopup();
}).addTo(map);

function setMapLayer(layer) {
  map.removeLayer(streetLayer);
  map.removeLayer(satelliteLayer);
  map.removeLayer(googleSatelliteLayer);
  if (map.hasLayer(labelsOverlay)) map.removeLayer(labelsOverlay);
  
  if (layer === 'street') {
    map.addLayer(streetLayer);
  } else if (layer === 'satellite') {
    map.addLayer(satelliteLayer);
    labelsOverlay.addTo(map);
  } else if (layer === 'google') {
    map.addLayer(googleSatelliteLayer);
    labelsOverlay.addTo(map);
  }
  
  currentLayer = layer;
  
  document.getElementById('layerStreet').classList.toggle('active', layer === 'street');
  document.getElementById('layerSatellite').classList.toggle('active', layer === 'satellite');
  document.getElementById('layerGoogle').classList.toggle('active', layer === 'google');
  applyElevationOverlayStyles();
}

/* ========== ANGLES MODE FUNCTIONALITY ========== */
let anglesAOILayer = null;
const anglesAllRoadsLayer = L.geoJSON(null, { 
  style: { weight: 1, opacity: 0.5, color: '#888' } 
}).addTo(map);

const anglesSegmentsLayer = L.geoJSON(null, { 
  style: { weight: 3, color: '#9D2235', opacity: 0.8 } 
}).addTo(map);

const anglesIntersectionsLayer = L.geoJSON(null, {
  pointToLayer: (f, latlng) => L.circleMarker(latlng, { 
    radius: 5, 
    weight: 1, 
    color: '#0066CC',
    fillColor: '#0066CC',
    fillOpacity: 0.7
  }),
  onEachFeature: (f, layer) => {
    const angle = f.properties?.angle?.toFixed(1);
    layer.bindPopup(`<div class="popup-title">Intersection Angle</div><div style="font-size:1.2rem;font-weight:700;color:#9D2235;text-align:center;margin-top:.5rem">${angle}°</div>`);
  }
}).addTo(map);

// Clear angles layers when needed
function clearAnglesLayers() {
  anglesAllRoadsLayer.clearLayers();
  anglesSegmentsLayer.clearLayers();
  anglesIntersectionsLayer.clearLayers();
  if (anglesAOILayer) {
    map.removeLayer(anglesAOILayer);
    anglesAOILayer = null;
  }
}

// Listen for polygon creation
map.on('pm:create', e => {
  if (mapMode === 'angles') {
    if (anglesAOILayer) map.removeLayer(anglesAOILayer);
    anglesAOILayer = e.layer.addTo(map);
    document.getElementById('status').textContent = 'Area selected - adjust settings and click Fetch';
  }
});

map.on('pm:remove', e => {
  if (e.layer === anglesAOILayer) {
    anglesAOILayer = null;
    clearAnglesLayers();
  }
});

function updateAngleMode() {
  const maxAllowed = document.querySelector('input[name="angleMode"]:checked').value === '180' ? 180 : 90;
  const rangeHint = document.getElementById('rangeHint');
  const minAngle = document.getElementById('minAngle');
  const maxAngle = document.getElementById('maxAngle');
  
  rangeHint.textContent = `Allowed: 0—${maxAllowed}°`;
  
  if (+minAngle.value > maxAllowed) minAngle.value = maxAllowed;
  if (+maxAngle.value > maxAllowed) maxAngle.value = maxAllowed;
}

function buildAnglesOverpassQL(polygonLatLngs, includedHighways) {
  const ring = polygonLatLngs.map(ll => `${ll.lat} ${ll.lng}`).join(' ');
  const hwyRegex = includedHighways.length ? `~"^(${includedHighways.join('|')})$"` : `~".*"`;
  return `
[out:json][timeout:60];
way(poly:"${ring}")["highway"${includedHighways.length ? hwyRegex : ''}]
  ["highway"!~"footway|path|cycleway|bridleway|steps|corridor|via_ferrata|pedestrian"];
out geom;
`;
}

async function fetchOSMRoads(ql) {
  const resp = await fetch('https://overpass-api.de/api/interpreter', {
    method: 'POST', 
    body: new URLSearchParams({ data: ql })
  });
  if (!resp.ok) throw new Error(`Overpass HTTP ${resp.status}`);
  const data = await resp.json();
  const features = (data.elements || [])
    .filter(el => el.type === 'way' && Array.isArray(el.geometry))
    .map(el => ({
      type: 'Feature',
      properties: { id: el.id, tags: el.tags || {} },
      geometry: { type: 'LineString', coordinates: el.geometry.map(g => [g.lon, g.lat]) }
    }));
  return { type: 'FeatureCollection', features };
}

function angleBetween(b1, b2, modeMax) {
  let x = Math.abs(b1 - b2) % 360;
  if (x > 180) x = 360 - x;
  if (modeMax === 90 && x > 90) x = 180 - x;
  return x;
}

function computeMatchesAsPointsAndSegments(fcLines, minDeg, maxDeg, modeMax) {
  const segs = [];
  fcLines.features.forEach(f => {
    const c = f.geometry.coordinates;
    for (let i = 0; i < c.length - 1; i++) segs.push({ a: c[i], b: c[i + 1] });
  });

  const key = (pt) => pt[0].toFixed(7) + "," + pt[1].toFixed(7);
  const nodeToSegIdx = new Map();
  segs.forEach((s, idx) => {
    const ka = key(s.a), kb = key(s.b);
    if (!nodeToSegIdx.has(ka)) nodeToSegIdx.set(ka, []);
    if (!nodeToSegIdx.has(kb)) nodeToSegIdx.set(kb, []);
    nodeToSegIdx.get(ka).push(idx);
    nodeToSegIdx.get(kb).push(idx);
  });

  const segBear = segs.map(s => {
    const bAB = turf.bearing(turf.point(s.a), turf.point(s.b));
    const bBA = (bAB + 180 + 360) % 360;
    return { bAB, bBA };
  });

  const hitPts = [], hitSegIdx = new Set();
  for (const [k, idxs] of nodeToSegIdx.entries()) {
    if (idxs.length < 2) continue;
    const [lon, lat] = k.split(',').map(Number);
    for (let i = 0; i < idxs.length; i++) {
      for (let j = i + 1; j < idxs.length; j++) {
        const si = idxs[i], sj = idxs[j];
        const bi = (key(segs[si].a) === k) ? segBear[si].bAB : segBear[si].bBA;
        const bj = (key(segs[sj].a) === k) ? segBear[sj].bAB : segBear[sj].bBA;
        const ang = angleBetween(bi, bj, modeMax);
        if (ang >= minDeg && ang <= maxDeg) {
          hitPts.push(turf.point([lon, lat], { angle: ang }));
          hitSegIdx.add(si); 
          hitSegIdx.add(sj);
        }
      }
    }
  }

  const segFeatures = Array.from(hitSegIdx).map(idx => ({
    type: 'Feature',
    properties: {},
    geometry: { type: 'LineString', coordinates: [segs[idx].a, segs[idx].b] }
  }));

  const seen = new Map();
  const mid = (minDeg + maxDeg) / 2;
  for (const p of hitPts) {
    const k2 = key(p.geometry.coordinates);
    const prev = seen.get(k2);
    if (!prev || Math.abs(prev.properties.angle - mid) > Math.abs(p.properties.angle - mid)) {
      seen.set(k2, p);
    }
  }
  
  return {
    points: turf.featureCollection(Array.from(seen.values())),
    segments: turf.featureCollection(segFeatures)
  };
}

function extractLeafletRing(layer) {
  const latlngs = layer.getLatLngs();
  const ring = Array.isArray(latlngs[0]) ? latlngs[0] : latlngs;
  const closed = ring.slice();
  if (closed.length && (closed[0].lat !== closed[closed.length - 1].lat || closed[0].lng !== closed[closed.length - 1].lng)) {
    closed.push(closed[0]);
  }
  return closed;
}

async function fetchAnglesData() {
  try {
    if (!anglesAOILayer || !anglesAOILayer.getLatLngs) {
      alert('Please draw a polygon area first using the drawing tools (top-right)');
      document.getElementById('status').textContent = 'Draw a polygon to start';
      return;
    }

    const maxAllowed = document.querySelector('input[name="angleMode"]:checked').value === '180' ? 180 : 90;
    const minA = Number(document.getElementById('minAngle').value);
    const maxA = Number(document.getElementById('maxAngle').value);
    
    if ([minA, maxA].some(isNaN) || minA < 0 || maxA > maxAllowed || minA > maxA) {
      alert(`Angle range must be between 0 and ${maxAllowed}°`);
      return;
    }

    const hwys = Array.from(document.querySelectorAll('.hwy:checked')).map(cb => cb.value);
    
    document.getElementById('status').textContent = 'Fetching OSM roads from Overpass...';
    
    // Don't clear the AOI layer, only the results
    anglesAllRoadsLayer.clearLayers();
    anglesSegmentsLayer.clearLayers();
    anglesIntersectionsLayer.clearLayers();

    const ring = extractLeafletRing(anglesAOILayer);
    const ql = buildAnglesOverpassQL(ring, hwys);
    const fc = await fetchOSMRoads(ql);

    if (document.getElementById('showAllRoads').checked) {
      anglesAllRoadsLayer.addData(fc);
    }

    document.getElementById('status').textContent = `Fetched ${fc.features.length} ways. Computing...`;
    
    const modeMax = maxAllowed;
    const result = computeMatchesAsPointsAndSegments(fc, minA, maxA, modeMax);

    anglesSegmentsLayer.addData(result.segments);
    anglesIntersectionsLayer.addData(result.points);

    const nPts = result.points.features.length;
    const nSegs = result.segments.features.length;
    document.getElementById('status').textContent = `Found ${nPts} intersections and ${nSegs} segments in ${minA}—${maxA}° range`;
    
    if (nPts || nSegs) {
      const group = L.featureGroup([anglesSegmentsLayer, anglesIntersectionsLayer]);
      map.fitBounds(group.getBounds(), { maxZoom: 18 });
    }
  } catch (err) {
    console.error(err);
    document.getElementById('status').textContent = 'Error: ' + err.message;
    alert('Overpass error. Try a smaller area or fewer highway types.');
  }
}

function downloadIntersections() {
  const fc = anglesIntersectionsLayer.toGeoJSON();
  if (!fc.features.length) {
    alert('No intersections to download');
    return;
  }
  const blob = new Blob([JSON.stringify(fc, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'intersections.geojson';
  a.click();
}

function downloadSegments() {
  const fc = anglesSegmentsLayer.toGeoJSON();
  if (!fc.features.length) {
    alert('No segments to download');
    return;
  }
  const blob = new Blob([JSON.stringify(fc, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'segments.geojson';
  a.click();
}

/* ========== PLACES MODE FUNCTIONALITY ========== */
const osmCategories = {
  'Services & Amenities': [
    'amenity', 'shop', 'office', 'craft', 'emergency', 'healthcare', 
    'public_transport', 'religion', 'education', 'social_facility'
  ],
  'Tourism & Leisure': [
    'tourism', 'leisure', 'sport', 'attraction', 'accommodation'
  ],
  'Transportation': [
    'highway', 'railway', 'aeroway', 'waterway', 'route', 'public_transport'
  ],
  'Physical Features': [
    'natural', 'landuse', 'waterway', 'coastline', 'seamark'
  ],
  'Built Environment': [
    'building', 'man_made', 'barrier', 'power', 'telecom'
  ],
  'Administrative': [
    'place', 'boundary', 'admin_level', 'postal_code'
  ],
  'Historical & Cultural': [
    'historic', 'archaeological_site', 'memorial', 'monument'
  ],
  'Military & Security': [
    'military', 'security', 'defence'
  ],
  'Other': [
    'entrance', 'access', 'fee', 'opening_hours', 'website', 'phone', 'email'
  ]
};

const allOsmCategories = [...new Set(Object.values(osmCategories).flat())];

let activeFilters = new Set(allOsmCategories);
let allPlaces = [];

// Track drawn markers per summary category (e.g., "amenity: cafe")
let markersByCategory = new Map();
// Categories toggled off from the Discovery Summary
let hiddenSummaryCategories = new Set();

function initFilters() {
  const grid = document.getElementById('filterGrid');
  grid.innerHTML = '';
  
  const processedCategories = new Set();
  
  Object.entries(osmCategories).forEach(([categoryName, categories]) => {
    const categoryDiv = document.createElement('div');
    categoryDiv.className = 'filter-category';
    
    // Filter out categories that have already been processed
    const uniqueCategories = categories.filter(cat => {
      if (processedCategories.has(cat)) {
        return false;
      }
      processedCategories.add(cat);
      return true;
    });
    
    categoryDiv.innerHTML = `
      <div class="category-header">
        <input type="checkbox" id="category_${categoryName}" checked onchange="toggleCategorySelection('${categoryName}')" class="category-checkbox">
        <span class="category-name" onclick="toggleCategory('${categoryName}')">${categoryName}</span>
        <span class="category-count">(${uniqueCategories.length})</span>
        <span class="category-toggle" onclick="toggleCategory('${categoryName}')">▼</span>
      </div>
      <div class="category-items" id="category_${categoryName}">
        ${uniqueCategories.map(cat => `
          <div class="filter-item checked">
            <input type="checkbox" id="filter_${cat}" checked onchange="toggleFilter('${cat}')">
            <label for="filter_${cat}">${cat}</label>
          </div>
        `).join('')}
      </div>
    `;
    grid.appendChild(categoryDiv);
  });
  
  updateFilterCount();
}

function toggleCategory(categoryName) {
  const categoryItems = document.getElementById(`category_${categoryName}`);
  const toggle = categoryItems.previousElementSibling.querySelector('.category-toggle');
  
  if (categoryItems.style.display === 'none') {
    categoryItems.style.display = 'block';
    toggle.textContent = '▼';
  } else {
    categoryItems.style.display = 'none';
    toggle.textContent = '▶';
  }
}

function toggleCategorySelection(categoryName) {
  const categoryCheckbox = document.getElementById(`category_${categoryName}`);
  const categories = osmCategories[categoryName];
  const isChecked = categoryCheckbox.checked;
  
  categories.forEach(cat => {
    const checkbox = document.getElementById(`filter_${cat}`);
    if (checkbox) { // Only process if checkbox exists (i.e., it's unique)
      const item = checkbox.parentElement;
      
      if (isChecked) {
        activeFilters.add(cat);
        checkbox.checked = true;
        item.classList.add('checked');
      } else {
        activeFilters.delete(cat);
        checkbox.checked = false;
        item.classList.remove('checked');
      }
    }
  });
  
  updateFilterCount();
  if (allPlaces.length > 0) filterAndDrawPlaces();
}

function toggleFilter(category) {
  const checkbox = document.getElementById(`filter_${category}`);
  const item = checkbox.parentElement;
  
  if (checkbox.checked) {
    activeFilters.add(category);
    item.classList.add('checked');
  } else {
    activeFilters.delete(category);
    item.classList.remove('checked');
  }
  
  updateCategoryCheckboxState(category);
  
  updateFilterCount();
  if (allPlaces.length > 0) filterAndDrawPlaces();
}

function updateCategoryCheckboxState(category) {
  for (const [categoryName, categories] of Object.entries(osmCategories)) {
    if (categories.includes(category)) {
      const categoryCheckbox = document.getElementById(`category_${categoryName}`);
      const selectedInCategory = categories.filter(cat => activeFilters.has(cat));
      
      if (selectedInCategory.length === 0) {
        categoryCheckbox.checked = false;
        categoryCheckbox.indeterminate = false;
      } else if (selectedInCategory.length === categories.length) {
        categoryCheckbox.checked = true;
        categoryCheckbox.indeterminate = false;
      } else {
        categoryCheckbox.checked = false;
        categoryCheckbox.indeterminate = true;
      }
      break;
    }
  }
}

function selectAllFilters() {
  allOsmCategories.forEach(cat => {
    activeFilters.add(cat);
    const checkbox = document.getElementById(`filter_${cat}`);
    if (checkbox) {
      checkbox.checked = true;
      checkbox.parentElement.classList.add('checked');
    }
  });
  
  Object.keys(osmCategories).forEach(categoryName => {
    const categoryCheckbox = document.getElementById(`category_${categoryName}`);
    if (categoryCheckbox) {
      categoryCheckbox.checked = true;
      categoryCheckbox.indeterminate = false;
    }
  });
  
  updateFilterCount();
  if (allPlaces.length > 0) filterAndDrawPlaces();
}

function deselectAllFilters() {
  activeFilters.clear();
  allOsmCategories.forEach(cat => {
    const checkbox = document.getElementById(`filter_${cat}`);
    if (checkbox) {
      checkbox.checked = false;
      checkbox.parentElement.classList.remove('checked');
    }
  });
  
  Object.keys(osmCategories).forEach(categoryName => {
    const categoryCheckbox = document.getElementById(`category_${categoryName}`);
    if (categoryCheckbox) {
      categoryCheckbox.checked = false;
      categoryCheckbox.indeterminate = false;
    }
  });
  
  updateFilterCount();
  cluster.clearLayers();
  updateSummary([]);
}

function updateFilterCount() {
  const countSpan = document.getElementById('filterCount');
  if (countSpan) countSpan.textContent = `(${activeFilters.size}/${allOsmCategories.length})`;
}

let mapMode = 'places';
let currentView = '2d';
let streetViewMarker = null;
let mapillaryViewer = null;
const mapCanvas = document.getElementById('mapCanvas');
const mapCanvasCtx = mapCanvas.getContext('2d');
let mapShapes = [];

function setMapMode(mode) {
  mapMode = mode;
  
  document.getElementById('placesMode').classList.toggle('active', mode === 'places');
  document.getElementById('groundMode').classList.toggle('active', mode === 'ground');
  document.getElementById('drawMode').classList.toggle('active', mode === 'draw');
  document.getElementById('losMode').classList.toggle('active', mode === 'los');
  document.getElementById('anglesMode').classList.toggle('active', mode === 'angles');
  
  document.getElementById('placesControls').style.display = mode === 'places' ? 'block' : 'none';
  document.getElementById('groundControls').style.display = mode === 'ground' ? 'block' : 'none';
  document.getElementById('anglesControls').style.display = mode === 'angles' ? 'block' : 'none';
  document.getElementById('losControls').style.display = mode === 'los' ? 'block' : 'none';
  
  if (mode === 'places') {
    mapCanvas.classList.remove('active');
    map.dragging.enable();
    document.getElementById('status').textContent = 'Click map to search places';
    clearAnglesLayers();
    
    if (currentView === '3d' || currentView === 'peakfinder') {
      toggleMapView();
    }
  } else if (mode === 'ground') {
    mapCanvas.classList.remove('active');
    map.dragging.enable();
    document.getElementById('status').textContent = 'Click map for ground view';
    clearAnglesLayers();
  } else if (mode === 'draw') {
    document.getElementById('status').textContent = 'Drawing mode active!';
    clearAnglesLayers();
    
    if (currentView === '2d') {
      mapCanvas.classList.add('active');
      map.dragging.disable();
      resizeMapCanvas();
    } else if (currentView === '3d') {
      view3DCanvas.classList.add('active');
      setup3DViewCanvas();
    }
  } else if (mode === 'los') {
    mapCanvas.classList.remove('active');
    map.dragging.enable();
    clearLineOfSight();
    clearAnglesLayers();
    loadMapboxToken();
    updateLOSStatus();
  } else if (mode === 'angles') {
    mapCanvas.classList.remove('active');
    map.dragging.enable();
    document.getElementById('status').textContent = 'Draw polygon area to analyze intersections';
    
    if (currentView === '3d' || currentView === 'peakfinder') {
      toggleMapView();
    }
  }
}

function toggleMapView() {
  const map2D = document.getElementById('map');
  const mapCanvas2D = document.getElementById('mapCanvas');
  const view3D = document.getElementById('view3DContainer');
  const peakFinder = document.getElementById('peakFinderContainer');
  const view3DCanvasEl = document.getElementById('view3DCanvas');
  const toggleBtn = document.getElementById('viewToggleBtn');
  const infoBar = document.getElementById('viewInfoBar');
  
  if (currentView === '2d') {
    if (losMode === 'peakfinder') {
      currentView = 'peakfinder';
      peakFinder.classList.add('active');
    } else {
      currentView = '3d';
      view3D.classList.add('active');
      if (mapMode === 'draw') {
        view3DCanvasEl.classList.add('active');
        setup3DViewCanvas();
      }
    }
    
    map2D.style.display = 'none';
    mapCanvas2D.style.display = 'none';
    mapCanvas2D.classList.remove('active');
    map.dragging.enable();
    
    toggleBtn.style.display = 'flex';
    infoBar.classList.add('visible');
    
    document.getElementById('viewToggleIcon').textContent = '🗺️';
    document.getElementById('viewToggleText').textContent = 'Back to 2D Map';
    
    if (window.map3D && currentView === '3d') {
      setTimeout(() => {
        window.map3D.resize();
        setup3DViewCanvas();
      }, 100);
    }
  } else {
    currentView = '2d';
    map2D.style.display = 'block';
    mapCanvas2D.style.display = 'block';
    view3D.classList.remove('active');
    peakFinder.classList.remove('active');
    view3DCanvasEl.classList.remove('active');
    toggleBtn.style.display = 'none';
    infoBar.classList.remove('visible');
    
    if (mapMode === 'draw') {
      mapCanvas2D.classList.add('active');
      map.dragging.disable();
    }
    
    setTimeout(() => {
      map.invalidateSize();
      if (mapMode === 'draw') resizeMapCanvas();
    }, 100);
  }
}

function resizeMapCanvas() {
  const mapContainer = document.getElementById('map');
  mapCanvas.width = mapContainer.offsetWidth;
  mapCanvas.height = mapContainer.offsetHeight;
  redrawMapCanvas();
}

map.on('resize', () => {
  if (mapMode === 'draw') resizeMapCanvas();
});

window.addEventListener('resize', () => {
  if (mapMode === 'draw') resizeMapCanvas();
});

let mapDrawing = false;
let mapStartX, mapStartY;
let mapPolygonPoints = [];

mapCanvas.addEventListener('mousedown', (e) => {
  if (mapMode !== 'draw') return;
  
  // Handle sticky note placement
  if (currentTool === 'note') {
    const rect = mapCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    createStickyNote(x, y, document.getElementById('map'));
    return;
  }
  
  const rect = mapCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  if (currentTool === 'polygon') {
    mapPolygonPoints.push({ x, y });
    redrawMapCanvas();
    
    mapCanvasCtx.fillStyle = currentColor;
    mapCanvasCtx.beginPath();
    mapCanvasCtx.arc(x, y, 4, 0, 2 * Math.PI);
    mapCanvasCtx.fill();
    
    return;
  }
  
  mapDrawing = true;
  mapStartX = x;
  mapStartY = y;
});

mapCanvas.addEventListener('mousemove', (e) => {
  if (!mapDrawing || mapMode !== 'draw') return;
  
  const rect = mapCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  redrawMapCanvas();
  
  const previewShape = {
    type: currentTool,
    color: currentColor,
    dashed: isDashed,
    lineWidth: currentLineWidth,
    filled: isFilled,
    fillOpacity: fillOpacity,
    startX: mapStartX, startY: mapStartY,
    endX: x, endY: y
  };
  
  drawShapeOnContext(mapCanvasCtx, previewShape);
});

mapCanvas.addEventListener('mouseup', (e) => {
  if (!mapDrawing || mapMode !== 'draw') return;
  
  const rect = mapCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const shape = {
    type: currentTool,
    color: currentColor,
    dashed: isDashed,
    lineWidth: currentLineWidth,
    filled: isFilled,
    fillOpacity: fillOpacity,
    startX: mapStartX, startY: mapStartY,
    endX: x, endY: y
  };
  
  mapShapes.push(shape);
  mapDrawing = false;
  redrawMapCanvas();
});

mapCanvas.addEventListener('dblclick', (e) => {
  if (currentTool === 'polygon' && mapPolygonPoints.length > 2 && mapMode === 'draw') {
    const shape = {
      type: 'polygon',
      color: currentColor,
      dashed: isDashed,
      lineWidth: currentLineWidth,
      filled: isFilled,
      fillOpacity: fillOpacity,
      points: [...mapPolygonPoints]
    };
    mapShapes.push(shape);
    mapPolygonPoints = [];
    redrawMapCanvas();
  }
});

function redrawMapCanvas() {
  mapCanvasCtx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
  mapShapes.forEach(shape => {
    drawShapeOnContext(mapCanvasCtx, shape);
  });
}

const cluster = L.markerClusterGroup({
  chunkedLoading: true,
  spiderfyOnMaxZoom: true,
  showCoverageOnHover: false,
  zoomToBoundsOnClick: true
});
map.addLayer(cluster);

let pin = null, circle = null;
const rSlider = document.getElementById('radiusSlider');
const rLabel = document.getElementById('radiusLabel');
const status = document.getElementById('status');
const summaryPanel = document.getElementById('summaryPanel');

function syncRadiusLabel() { rLabel.textContent = rSlider.value; }
syncRadiusLabel();

rSlider.addEventListener('input', () => {
  syncRadiusLabel();
  if (circle) circle.setRadius(+rSlider.value);
  if (pin) queryOverpass();
});

map.on('click', e => {
  if (mapMode === 'places') {
    cluster.clearLayers();
    if (pin) map.removeLayer(pin);
    if (circle) map.removeLayer(circle);

    pin = L.marker(e.latlng, {
      icon: L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      })
    }).addTo(map);

    circle = L.circle(e.latlng, {
      radius: +rSlider.value,
      color: '#9D2235',
      weight: 2,
      fillOpacity: 0.1
    }).addTo(map);

    queryOverpass();
    
    document.getElementById('streetViewControls').classList.remove('visible');
  } else if (mapMode === 'ground') {
    if (streetViewMarker && streetViewMarker.marker) {
      map.removeLayer(streetViewMarker.marker);
    }
    
    const marker = L.marker(e.latlng, {
      icon: L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      })
    }).addTo(map).bindPopup('Ground View Location').openPopup();
    
    streetViewMarker = {
      lat: e.latlng.lat,
      lng: e.latlng.lng,
      marker: marker
    };
    
    const controls = document.getElementById('streetViewControls');
    controls.classList.add('visible');
    document.getElementById('status').textContent = 'Location selected - Choose a view option';
  } else if (mapMode === 'los') {
    handleLOSClick(e.latlng);
  }
});

function buildQuery(lat, lon, r) {
  const activeList = Array.from(activeFilters);
  let parts = [];
  
  activeList.forEach(k => {
    parts.push(`node(around:${r},${lat},${lon})["${k}"];`);
    parts.push(`way(around:${r},${lat},${lon})["${k}"];`);
    parts.push(`rel(around:${r},${lat},${lon})["${k}"];`);
  });
  
  return `[out:json][timeout:30];(${parts.join('')});out center tags;`;
}

async function queryOverpass() {
  const {lat, lng} = pin.getLatLng();
  const radius = rSlider.value;
  status.textContent = 'Querying OpenStreetMap...';
  summaryPanel.classList.remove('visible');

  try {
    const res = await fetch('https://overpass-api.de/api/interpreter', {
      method: 'POST',
      body: buildQuery(lat.toFixed(6), lng.toFixed(6), radius),
      headers: {'Content-Type': 'text/plain'}
    });
    
    if (!res.ok) throw new Error('Network error');
    
    const data = await res.json();
    allPlaces = data.elements;
    
    status.textContent = `Found ${allPlaces.length} places`;
    filterAndDrawPlaces();
    
  } catch (err) {
    console.error(err);
    status.textContent = 'Failed to load data';
    allPlaces = [];
  }
}

function filterAndDrawPlaces() {
  const filtered = allPlaces.filter(el => {
    const tags = el.tags || {};
    return allOsmCategories.some(cat => tags[cat] && activeFilters.has(cat));
  });
  
  drawElements(filtered);
  updateSummary(filtered);
  summaryPanel.classList.add('visible');
}

function drawElements(els) {
  cluster.clearLayers();
  markersByCategory.clear();
  
  els.forEach(el => {
    let lat, lon;
    if (el.type === 'node') {
      lat = el.lat;
      lon = el.lon;
    } else if (el.center) {
      lat = el.center.lat;
      lon = el.center.lon;
    }
    
    if (!lat || !lon) return;

    const tags = el.tags || {};
    const name = tags.name || tags['name:en'] || tags.ref || '(Unnamed location)';
    const category = getCategory(tags);
    const summaryCategory = category; // e.g., "amenity: cafe" or "miscellaneous"
    const gMapsUrl = `https://www.google.com/maps?q=${lat},${lon}`;
    
    const tagList = Object.entries(tags)
      .filter(([k,v]) => k !== 'name' && k !== 'name:en')
      .slice(0, 10)
      .map(([k,v]) => `<span class="popup-tag">${escapeHtml(k)}: ${escapeHtml(v)}</span>`)
      .join('');

    const popupHtml = `
      <div class="popup-title">${escapeHtml(name)}</div>
      <div class="popup-category">${escapeHtml(category)}</div>
      ${tagList ? `<div class="popup-tags">${tagList}</div>` : ''}
      <a href="${gMapsUrl}" target="_blank" rel="noopener noreferrer" class="popup-link">
        Open in Google Maps
      </a>
    `;

    const markerColor = getMarkerColor(category);
    const marker = L.marker([lat, lon], {
      icon: L.icon({
        iconUrl: markerColor,
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      })
    });
    
    marker.bindPopup(popupHtml, {maxWidth: 300});
    // Store marker in registry
    if (!markersByCategory.has(summaryCategory)) {
      markersByCategory.set(summaryCategory, []);
    }
    markersByCategory.get(summaryCategory).push(marker);
    // Add to map only if category is not hidden
    if (!hiddenSummaryCategories.has(summaryCategory)) {
      cluster.addLayer(marker);
    }
  });
}

function getCategory(tags) {
  for (const k of allOsmCategories) {
    if (tags[k]) return `${k}: ${tags[k]}`;
  }
  return 'miscellaneous';
}

function getMarkerColor(category) {
  const colors = {
    'amenity': 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
    'shop': 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
    'tourism': 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-orange.png',
    'leisure': 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-yellow.png',
    'historic': 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-violet.png',
  };
  
  for (const [key, color] of Object.entries(colors)) {
    if (category.startsWith(key)) return color;
  }
  
  return 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-grey.png';
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

function updateSummary(places) {
  document.getElementById('totalPlaces').textContent = places.length;
  
  const categoryData = {};
  places.forEach(el => {
    const tags = el.tags || {};
    for (const cat of allOsmCategories) {
      if (tags[cat]) {
        const key = `${cat}: ${tags[cat]}`;
        if (!categoryData[key]) {
          categoryData[key] = [];
        }
        categoryData[key].push(el);
      }
    }
  });
  
  const uniqueCategories = Object.keys(categoryData).length;
  document.getElementById('totalCategories').textContent = uniqueCategories;
  
  const categoryList = document.getElementById('categoryList');
  categoryList.innerHTML = '';
  
  const sorted = Object.entries(categoryData)
    .sort((a,b) => b[1].length - a[1].length)
    .slice(0, 15);
  
  if (sorted.length === 0) {
    categoryList.innerHTML = '<p style="color:#999;font-size:.8rem;text-align:center;padding:.8rem">No places found</p>';
  } else {
    sorted.forEach(([cat, placesList], index) => {
      const div = document.createElement('div');
      div.className = 'category-item';
      const categoryId = `cat-${index}`;
      
      div.innerHTML = `
        <div class="category-header">
          <label style="display:flex;align-items:center;gap:.5rem;flex:1;cursor:pointer" title="Show/Hide pins in this category">
            <input type="checkbox" ${hiddenSummaryCategories.has(cat) ? '' : 'checked'} onchange="toggleSummaryCategory('${cat.replace(/'/g, "&#39;")}')" style="cursor:pointer">
            <span class="name">${escapeHtml(cat)}</span>
          </label>
          <span class="count">${placesList.length}</span>
          <span class="toggle-icon" id="icon-${categoryId}" onclick="toggleCategoryDisplay('${categoryId}')">▼</span>
        </div>
        <div class="category-places" id="${categoryId}">
          ${placesList.map(place => {
            const name = place.tags.name || place.tags['name:en'] || place.tags.ref || '(Unnamed)';
            let lat, lon;
            if (place.type === 'node') {
              lat = place.lat;
              lon = place.lon;
            } else if (place.center) {
              lat = place.center.lat;
              lon = place.center.lon;
            }
            
            return `
              <div class="place-item" onclick="centerMapOnPlace(${lat}, ${lon}, '${escapeHtml(name).replace(/'/g, "&#39;")}')">
                <span class="icon">📍</span>
                <span class="text">${escapeHtml(name)}</span>
              </div>
            `;
          }).join('')}
        </div>
      `;
      categoryList.appendChild(div);
    });
  }
}

function toggleCategoryDisplay(categoryId) {
  const placesDiv = document.getElementById(categoryId);
  const icon = document.getElementById(`icon-${categoryId}`);
  
  placesDiv.classList.toggle('expanded');
  icon.classList.toggle('expanded');
}

// Show/hide markers for a given summary category label (e.g., "amenity: cafe")
function toggleSummaryCategory(catLabel) {
  if (hiddenSummaryCategories.has(catLabel)) {
    hiddenSummaryCategories.delete(catLabel);
    const arr = markersByCategory.get(catLabel) || [];
    arr.forEach(m => {
      if (!cluster.hasLayer(m)) cluster.addLayer(m);
    });
  } else {
    hiddenSummaryCategories.add(catLabel);
    const arr = markersByCategory.get(catLabel) || [];
    arr.forEach(m => {
      if (cluster.hasLayer(m)) cluster.removeLayer(m);
    });
  }
}

function centerMapOnPlace(lat, lon, name) {
  if (lat && lon) {
    map.setView([lat, lon], 20);
    
    cluster.eachLayer(marker => {
      const markerLatLng = marker.getLatLng();
      if (Math.abs(markerLatLng.lat - lat) < 0.0001 && Math.abs(markerLatLng.lng - lon) < 0.0001) {
        marker.openPopup();
      }
    });
  }
}

/* ========== RESIZER ========== */
const resizer = document.getElementById('resizer');
const mapPanel = document.querySelector('.map-panel');
const imagePanel = document.getElementById('imagePanel');

let isResizing = false;

function handleResizerMouseDown(e) {
  e.preventDefault();
  e.stopPropagation();
  isResizing = true;
  document.body.style.cursor = 'col-resize';
  document.body.style.userSelect = 'none';
  document.body.classList.add('resizing');
}

function handleResizerMouseMove(e) {
  if (!isResizing) return;
  
  e.preventDefault();
  e.stopPropagation();
  
  const containerWidth = document.querySelector('.content-container').offsetWidth;
  const newMapWidth = (e.clientX / containerWidth) * 100;
  
  if (newMapWidth > 20 && newMapWidth < 80) {
    mapPanel.style.flex = `0 0 ${newMapWidth}%`;
    imagePanel.style.flex = `0 0 ${100 - newMapWidth}%`;
    
    requestAnimationFrame(() => {
      map.invalidateSize();
      if (mapMode === 'draw') resizeMapCanvas();
    });
  }
}

function handleResizerMouseUp(e) {
  if (isResizing) {
    e.preventDefault();
    e.stopPropagation();
    isResizing = false;
    document.body.style.cursor = 'default';
    document.body.style.userSelect = 'auto';
    document.body.classList.remove('resizing');
  }
}

resizer.addEventListener('mousedown', handleResizerMouseDown, { passive: false });
document.addEventListener('mousemove', handleResizerMouseMove, { passive: false });
document.addEventListener('mouseup', handleResizerMouseUp, { passive: false });

document.addEventListener('mouseleave', () => {
  if (isResizing) {
    isResizing = false;
    document.body.style.cursor = 'default';
    document.body.style.userSelect = 'auto';
    document.body.classList.remove('resizing');
  }
});

/* ========== IMAGE UPLOAD & LAYER MANAGEMENT ========== */
let imageLayers = [];
let selectedLayerId = null;
let isDraggingLayer = false;
let isResizingLayer = false;
let resizeHandle = null;
let dragOffsetX = 0;
let dragOffsetY = 0;
let resizeStartX = 0;
let resizeStartY = 0;
let resizeStartScale = 1;
let resizeStartLayerX = 0;
let resizeStartLayerY = 0;

const imageUpload = document.getElementById('imageUpload');
const imageViewer = document.getElementById('imageViewer');
const imageCanvas = document.getElementById('imageCanvas');
const ctx = imageCanvas.getContext('2d');

function initializeCanvas() {
  const container = document.querySelector('.image-canvas-container');
  imageCanvas.width = container.clientWidth;
  imageCanvas.height = container.clientHeight;
  imageCanvas.style.width = container.clientWidth + 'px';
  imageCanvas.style.height = container.clientHeight + 'px';
}

window.addEventListener('resize', () => {
  if (imageLayers.length > 0) {
    initializeCanvas();
    redrawAllLayers();
  }
});

imageUpload.addEventListener('change', (e) => {
  const files = Array.from(e.target.files);
  files.forEach(file => {
    const reader = new FileReader();
    reader.onload = (event) => {
      const img = new Image();
      img.onload = () => {
        const layer = {
          id: Date.now() + Math.random(),
          name: file.name,
          image: img,
          x: 50,
          y: 50,
          opacity: 1.0,
          visible: true,
          scale: 1.0,
          rotation: 0
        };
        
        imageLayers.push(layer);
        updateLayersList();
        
        if (imageLayers.length === 1) {
          document.querySelector('.no-image').style.display = 'none';
          document.querySelector('.image-canvas-container').style.display = 'flex';
          imagePanel.classList.remove('hidden');
          initializeCanvas();
        }
        
        redrawAllLayers();
      };
      img.src = event.target.result;
    };
    reader.readAsDataURL(file);
  });
  e.target.value = '';
});

function addProtractorImage() {
  const img = new Image();
  img.onload = () => {
    const layer = {
      id: Date.now() + Math.random(),
      name: 'Protractor',
      image: img,
      x: 50,
      y: 50,
      opacity: 1.0,
      visible: true,
      scale: 1.0,
      rotation: 0
    };
    
    imageLayers.push(layer);
    updateLayersList();
    
    if (imageLayers.length === 1) {
      document.querySelector('.no-image').style.display = 'none';
      document.querySelector('.image-canvas-container').style.display = 'flex';
      imagePanel.classList.remove('hidden');
      initializeCanvas();
    }
    
    redrawAllLayers();
  };
  img.onerror = () => {
    alert('Failed to load protractor image. Please make sure protractor.png exists in the same directory as this file.');
  };
  img.src = 'protractor.png';
}

const imageCanvasContainer = document.querySelector('.image-canvas-container');

['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
  document.addEventListener(eventName, preventDefaults, false);
});

function preventDefaults(e) {
  e.preventDefault();
  e.stopPropagation();
}

['dragenter', 'dragover'].forEach(eventName => {
  imageCanvasContainer.addEventListener(eventName, highlight, false);
});

['dragleave', 'drop'].forEach(eventName => {
  imageCanvasContainer.addEventListener(eventName, unhighlight, false);
});

['dragenter', 'dragover'].forEach(eventName => {
  imageCanvas.addEventListener(eventName, highlight, false);
});

['dragleave', 'drop'].forEach(eventName => {
  imageCanvas.addEventListener(eventName, unhighlight, false);
});

function highlight(e) {
  imageCanvasContainer.classList.add('drag-over');
}

function unhighlight(e) {
  imageCanvasContainer.classList.remove('drag-over');
}

imageCanvasContainer.addEventListener('drop', handleDrop, false);
imageCanvas.addEventListener('drop', (e) => {
  e.stopPropagation();
  handleDrop(e);
}, false);

function handleDrop(e) {
  e.preventDefault();
  e.stopPropagation();
  const dt = e.dataTransfer;
  const files = Array.from(dt.files);
  
  const imageFiles = files.filter(file => file.type.startsWith('image/'));
  
  if (imageFiles.length === 0) {
    alert('Please drop only image files.');
    return;
  }
  
  imageFiles.forEach(file => {
    const reader = new FileReader();
    reader.onload = (event) => {
      const img = new Image();
      img.onload = () => {
        const layer = {
          id: Date.now() + Math.random(),
          name: file.name,
          image: img,
          x: 50,
          y: 50,
          opacity: 1.0,
          visible: true,
          scale: 1.0,
          rotation: 0
        };
        
        imageLayers.push(layer);
        updateLayersList();
        
        if (imageLayers.length === 1) {
          document.querySelector('.no-image').style.display = 'none';
          document.querySelector('.image-canvas-container').style.display = 'flex';
          imagePanel.classList.remove('hidden');
          initializeCanvas();
        }
        
        redrawAllLayers();
      };
      img.src = event.target.result;
    };
    reader.readAsDataURL(file);
  });
}

function updateLayersList() {
  const list = document.getElementById('layersList');
  
  if (imageLayers.length === 0) {
    list.innerHTML = '<p class="no-layers">No images uploaded</p>';
    return;
  }
  
  list.innerHTML = '';
  
  [...imageLayers].reverse().forEach((layer, index) => {
    const div = document.createElement('div');
    div.className = `layer-item ${selectedLayerId === layer.id ? 'active' : ''}`;
    div.onclick = () => selectLayer(layer.id);
    
    const canvas = document.createElement('canvas');
    canvas.width = 40;
    canvas.height = 40;
    const ctx = canvas.getContext('2d');
    
    const scale = Math.min(40 / layer.image.width, 40 / layer.image.height);
    const w = layer.image.width * scale;
    const h = layer.image.height * scale;
    ctx.drawImage(layer.image, (40 - w) / 2, (40 - h) / 2, w, h);
    
    div.innerHTML = `
      <span class="layer-visibility" onclick="toggleLayerVisibility(${layer.id}, event)" title="${layer.visible ? 'Hide' : 'Show'}">
        ${layer.visible ? '👁️' : '🚫'}
      </span>
      <img class="layer-preview" src="${canvas.toDataURL()}" alt="preview"/>
      <div class="layer-info">
        <div class="layer-name" title="${layer.name}">${layer.name}</div>
      </div>
      <div class="layer-controls">
        <div class="layer-control-row">
          <span class="control-label">Opacity:</span>
          <input type="range" min="0" max="100" value="${layer.opacity * 100}" 
                 onchange="updateLayerOpacity(${layer.id}, this.value)" 
                 oninput="updateLayerOpacity(${layer.id}, this.value)"
                 onclick="event.stopPropagation()" 
                 title="Opacity: ${Math.round(layer.opacity * 100)}%"/>
        </div>
        <div class="layer-control-row">
          <span class="control-label">Scale:</span>
          <input type="range" min="10" max="300" value="${layer.scale * 100}" 
                 onchange="updateLayerScale(${layer.id}, this.value)" 
                 oninput="updateLayerScale(${layer.id}, this.value)"
                 onclick="event.stopPropagation()" 
                 title="Scale: ${Math.round(layer.scale * 100)}%"/>
        </div>
        <div class="layer-control-row">
          <span class="control-label">Rotation:</span>
          <button class="layer-btn" onclick="rotateLayerLeft(${layer.id}, event)" title="Rotate left 5°">↶</button>
          <button class="layer-btn" onclick="rotateLayerRight(${layer.id}, event)" title="Rotate right 5°">↷</button>
          <button class="layer-btn" onclick="rotateLayerFineLeft(${layer.id}, event)" title="Rotate left 1°">↶</button>
          <button class="layer-btn" onclick="rotateLayerFineRight(${layer.id}, event)" title="Rotate right 1°">↷</button>
          <button class="layer-btn" onclick="resetLayerRotation(${layer.id}, event)" title="Reset rotation">⟲</button>
        </div>
        <div class="layer-control-row">
          <button class="layer-btn" onclick="moveLayerUp(${layer.id}, event)" title="Move up">▲</button>
          <button class="layer-btn" onclick="moveLayerDown(${layer.id}, event)" title="Move down">▼</button>
          <button class="layer-btn" onclick="removeLayer(${layer.id}, event)" title="Remove">×</button>
        </div>
      </div>
    `;
    
    list.appendChild(div);
  });
}

function selectLayer(layerId) {
  selectedLayerId = layerId;
  updateLayersList();
}

function toggleLayerVisibility(layerId, event) {
  event.stopPropagation();
  const layer = imageLayers.find(l => l.id === layerId);
  if (layer) {
    layer.visible = !layer.visible;
    updateLayersList();
    redrawAllLayers();
  }
}

function updateLayerOpacity(layerId, value) {
  const layer = imageLayers.find(l => l.id === layerId);
  if (layer) {
    layer.opacity = value / 100;
    redrawAllLayers();
  }
}

function updateLayerScale(layerId, value) {
  const layer = imageLayers.find(l => l.id === layerId);
  if (layer) {
    layer.scale = value / 100;
    redrawAllLayers();
  }
}

function rotateLayerLeft(layerId, event) {
  event.stopPropagation();
  const layer = imageLayers.find(l => l.id === layerId);
  if (layer) {
    layer.rotation = (layer.rotation || 0) - 5;
    if (layer.rotation < 0) layer.rotation += 360;
    redrawAllLayers();
    updateLayersList();
  }
}

function rotateLayerRight(layerId, event) {
  event.stopPropagation();
  const layer = imageLayers.find(l => l.id === layerId);
  if (layer) {
    layer.rotation = (layer.rotation || 0) + 5;
    if (layer.rotation >= 360) layer.rotation -= 360;
    redrawAllLayers();
    updateLayersList();
  }
}

function rotateLayerFineLeft(layerId, event) {
  event.stopPropagation();
  const layer = imageLayers.find(l => l.id === layerId);
  if (layer) {
    layer.rotation = (layer.rotation || 0) - 1;
    if (layer.rotation < 0) layer.rotation += 360;
    redrawAllLayers();
    updateLayersList();
  }
}

function rotateLayerFineRight(layerId, event) {
  event.stopPropagation();
  const layer = imageLayers.find(l => l.id === layerId);
  if (layer) {
    layer.rotation = (layer.rotation || 0) + 1;
    if (layer.rotation >= 360) layer.rotation -= 360;
    redrawAllLayers();
    updateLayersList();
  }
}

function resetLayerRotation(layerId, event) {
  event.stopPropagation();
  const layer = imageLayers.find(l => l.id === layerId);
  if (layer) {
    layer.rotation = 0;
    redrawAllLayers();
    updateLayersList();
  }
}

function moveLayerUp(layerId, event) {
  event.stopPropagation();
  const index = imageLayers.findIndex(l => l.id === layerId);
  if (index < imageLayers.length - 1) {
    [imageLayers[index], imageLayers[index + 1]] = [imageLayers[index + 1], imageLayers[index]];
    updateLayersList();
    redrawAllLayers();
  }
}

function moveLayerDown(layerId, event) {
  event.stopPropagation();
  const index = imageLayers.findIndex(l => l.id === layerId);
  if (index > 0) {
    [imageLayers[index], imageLayers[index - 1]] = [imageLayers[index - 1], imageLayers[index]];
    updateLayersList();
    redrawAllLayers();
  }
}

function removeLayer(layerId, event) {
  event.stopPropagation();
  imageLayers = imageLayers.filter(l => l.id !== layerId);
  if (selectedLayerId === layerId) selectedLayerId = null;
  
  updateLayersList();
  
  if (imageLayers.length === 0) {
    document.querySelector('.no-image').style.display = 'flex';
    document.querySelector('.image-canvas-container').style.display = 'none';
  } else {
    redrawAllLayers();
  }
}

function redrawAllLayers() {
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
  ctx.setTransform(imageZoom, 0, 0, imageZoom, imagePanX, imagePanY);
  
  imageLayers.forEach(layer => {
    if (layer.visible) {
      ctx.save();
      
      // Apply rotation around the center of the image
      const w = layer.image.width * layer.scale;
      const h = layer.image.height * layer.scale;
      const centerX = layer.x + w / 2;
      const centerY = layer.y + h / 2;
      
      ctx.translate(centerX, centerY);
      ctx.rotate((layer.rotation || 0) * Math.PI / 180);
      ctx.translate(-centerX, -centerY);
      
      ctx.globalAlpha = layer.opacity;
      ctx.drawImage(layer.image, layer.x, layer.y, w, h);
      
      ctx.restore();
      
      if (layer.id === selectedLayerId) {
        ctx.save();
        ctx.globalAlpha = 1.0;
        
        // Draw bounding box with rotation
        ctx.translate(centerX, centerY);
        ctx.rotate((layer.rotation || 0) * Math.PI / 180);
        ctx.translate(-centerX, -centerY);
        
        ctx.strokeStyle = '#9D2235';
        ctx.lineWidth = Math.max(1, 2 / imageZoom);
        ctx.setLineDash([10, 5]);
        ctx.strokeRect(layer.x, layer.y, w, h);
        ctx.setLineDash([]);
        
        const handleSize = 8 / imageZoom;
        ctx.fillStyle = '#9D2235';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = Math.max(1, 2 / imageZoom);
        
        // Corner resize handles
        ctx.beginPath();
        ctx.arc(layer.x, layer.y, handleSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(layer.x + w, layer.y, handleSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(layer.x, layer.y + h, handleSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(layer.x + w, layer.y + h, handleSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        ctx.restore();
      }
    }
  });
  
  drawingShapes.forEach(shape => {
    drawShapeOnContext(ctx, shape);
  });
  ctx.setTransform(1, 0, 0, 1, 0, 0);
}

function getResizeHandle(x, y, layer) {
  const handleSize = 8;
  const w = layer.image.width * layer.scale;
  const h = layer.image.height * layer.scale;
  
  // Transform point to account for rotation
  const centerX = layer.x + w / 2;
  const centerY = layer.y + h / 2;
  const angle = -(layer.rotation || 0) * Math.PI / 180;
  
  const dx = x - centerX;
  const dy = y - centerY;
  const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle) + centerX;
  const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle) + centerY;
  
  if (Math.sqrt(Math.pow(rotatedX - layer.x, 2) + Math.pow(rotatedY - layer.y, 2)) <= handleSize) {
    return 'tl';
  }
  if (Math.sqrt(Math.pow(rotatedX - (layer.x + w), 2) + Math.pow(rotatedY - layer.y, 2)) <= handleSize) {
    return 'tr';
  }
  if (Math.sqrt(Math.pow(rotatedX - layer.x, 2) + Math.pow(rotatedY - (layer.y + h), 2)) <= handleSize) {
    return 'bl';
  }
  if (Math.sqrt(Math.pow(rotatedX - (layer.x + w), 2) + Math.pow(rotatedY - (layer.y + h), 2)) <= handleSize) {
    return 'br';
  }
  
  return null;
}

function getRotateHandle(x, y, layer) {
  // Function removed - rotation now handled by buttons
  return false;
}

imageCanvas.addEventListener('mousedown', (e) => {
  // Handle sticky note placement
  if (currentTool === 'note') {
    const rect = imageCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    createStickyNote(x, y, document.querySelector('.image-canvas-container'));
    return;
  }
  
  if (currentTool === 'pan') {
    const coords = getCanvasCoords(e, imageCanvas);
    
    if (selectedLayerId) {
      const selectedLayer = imageLayers.find(l => l.id === selectedLayerId);
      if (selectedLayer && selectedLayer.visible) {
        const handle = getResizeHandle(coords.x, coords.y, selectedLayer);
        if (handle) {
          isResizingLayer = true;
          resizeHandle = handle;
          resizeStartX = coords.x;
          resizeStartY = coords.y;
          resizeStartScale = selectedLayer.scale;
          resizeStartLayerX = selectedLayer.x;
          resizeStartLayerY = selectedLayer.y;
          return;
        }
      }
    }
    
    for (let i = imageLayers.length - 1; i >= 0; i--) {
      const layer = imageLayers[i];
      if (!layer.visible) continue;
      
      const right = layer.x + layer.image.width * layer.scale;
      const bottom = layer.y + layer.image.height * layer.scale;
      
      if (coords.x >= layer.x && coords.x <= right &&
          coords.y >= layer.y && coords.y <= bottom) {
        isDraggingLayer = true;
        selectedLayerId = layer.id;
        dragOffsetX = coords.x - layer.x;
        dragOffsetY = coords.y - layer.y;
        updateLayersList();
        return;
      }
    }
  }
  
  if (!isDraggingLayer && !isResizingLayer && currentTool !== 'pan' && currentTool !== 'note') {
    handleDrawingMouseDown(e);
  }
});

imageCanvas.addEventListener('mousemove', (e) => {
  const coords = getCanvasCoords(e, imageCanvas);
  
  if (currentTool === 'pan' && selectedLayerId && !isDraggingLayer && !isResizingLayer) {
    const selectedLayer = imageLayers.find(l => l.id === selectedLayerId);
    if (selectedLayer && selectedLayer.visible) {
      const handle = getResizeHandle(coords.x, coords.y, selectedLayer);
      if (handle === 'tl' || handle === 'br') {
        imageCanvas.style.cursor = 'nwse-resize';
      } else if (handle === 'tr' || handle === 'bl') {
        imageCanvas.style.cursor = 'nesw-resize';
      } else {
        imageCanvas.style.cursor = 'grab';
      }
    }
  }
  
  if (isDraggingLayer && selectedLayerId) {
    const layer = imageLayers.find(l => l.id === selectedLayerId);
    if (layer) {
      layer.x = coords.x - dragOffsetX;
      layer.y = coords.y - dragOffsetY;
      redrawAllLayers();
    }
  } else if (isResizingLayer && selectedLayerId) {
    const layer = imageLayers.find(l => l.id === selectedLayerId);
    if (layer) {
      const dx = coords.x - resizeStartX;
      const dy = coords.y - resizeStartY;
      
      let scaleChange = 0;
      
      if (resizeHandle === 'br') {
        scaleChange = (dx + dy) / (layer.image.width + layer.image.height);
      } else if (resizeHandle === 'tl') {
        scaleChange = (-dx - dy) / (layer.image.width + layer.image.height);
        const newScale = Math.max(0.1, resizeStartScale + scaleChange);
        layer.x = resizeStartLayerX - (newScale - resizeStartScale) * layer.image.width;
        layer.y = resizeStartLayerY - (newScale - resizeStartScale) * layer.image.height;
      } else if (resizeHandle === 'tr') {
        scaleChange = (dx - dy) / (layer.image.width + layer.image.height);
        const newScale = Math.max(0.1, resizeStartScale + scaleChange);
        layer.y = resizeStartLayerY - (newScale - resizeStartScale) * layer.image.height;
      } else if (resizeHandle === 'bl') {
        scaleChange = (-dx + dy) / (layer.image.width + layer.image.height);
        const newScale = Math.max(0.1, resizeStartScale + scaleChange);
        layer.x = resizeStartLayerX - (newScale - resizeStartScale) * layer.image.width;
      }
      
      layer.scale = Math.max(0.1, Math.min(3, resizeStartScale + scaleChange));
      redrawAllLayers();
      updateLayersList();
    }
  } else if (imageDrawing) {
    handleDrawingMouseMove(e);
  }
});

imageCanvas.addEventListener('mouseup', (e) => {
  if (isDraggingLayer) {
    isDraggingLayer = false;
  } else if (isResizingLayer) {
    isResizingLayer = false;
    resizeHandle = null;
  } else if (imageDrawing) {
    handleDrawingMouseUp(e);
  }
  
  if (currentTool === 'pan') {
    imageCanvas.style.cursor = 'grab';
  }
});

/* ========== DRAWING TOOLS ========== */
let currentTool = 'pan';
let currentColor = '#FF4444';
let isDashed = false;
let currentLineWidth = 2;
let isFilled = false;
let fillOpacity = 20;
let imageDrawing = false;
let imageStartX, imageStartY;
let imagePolygonPoints = [];
let drawingShapes = [];

/* ========== STICKY NOTES ========== */
let stickyNotes = [];
let draggedNote = null;
let dragOffsetNoteX = 0;
let dragOffsetNoteY = 0;
let noteIdCounter = 0;

function createStickyNote(x, y, container) {
  const noteId = `note-${noteIdCounter++}`;
  
  const noteDiv = document.createElement('div');
  noteDiv.className = 'sticky-note';
  noteDiv.id = noteId;
  noteDiv.style.left = x + 'px';
  noteDiv.style.top = y + 'px';
  
  noteDiv.innerHTML = `
    <div class="sticky-note-header">
      <span class="sticky-note-drag-handle">⠿⠿</span>
      <button class="sticky-note-delete" onclick="deleteStickyNote('${noteId}')" title="Delete note">×</button>
    </div>
    <textarea class="sticky-note-textarea" placeholder="Type your note here..." onclick="event.stopPropagation()"></textarea>
  `;
  
  container.appendChild(noteDiv);
  
  const note = {
    id: noteId,
    element: noteDiv,
    container: container
  };
  
  stickyNotes.push(note);
  
  // Make draggable
  const header = noteDiv.querySelector('.sticky-note-header');
  header.addEventListener('mousedown', (e) => startDragNote(e, note));
  
  // Focus textarea
  setTimeout(() => {
    noteDiv.querySelector('.sticky-note-textarea').focus();
  }, 100);
  
  return note;
}

function startDragNote(e, note) {
  e.preventDefault();
  e.stopPropagation();
  
  draggedNote = note;
  note.element.classList.add('dragging');
  
  const rect = note.element.getBoundingClientRect();
  const containerRect = note.container.getBoundingClientRect();
  
  dragOffsetNoteX = e.clientX - rect.left;
  dragOffsetNoteY = e.clientY - rect.top;
}

document.addEventListener('mousemove', (e) => {
  if (!draggedNote) return;
  
  e.preventDefault();
  const containerRect = draggedNote.container.getBoundingClientRect();
  
  let newX = e.clientX - containerRect.left - dragOffsetNoteX;
  let newY = e.clientY - containerRect.top - dragOffsetNoteY;
  
  // Keep within bounds
  newX = Math.max(0, Math.min(newX, containerRect.width - draggedNote.element.offsetWidth));
  newY = Math.max(0, Math.min(newY, containerRect.height - draggedNote.element.offsetHeight));
  
  draggedNote.element.style.left = newX + 'px';
  draggedNote.element.style.top = newY + 'px';
});

document.addEventListener('mouseup', () => {
  if (draggedNote) {
    draggedNote.element.classList.remove('dragging');
    draggedNote = null;
  }
});

function deleteStickyNote(noteId) {
  const note = stickyNotes.find(n => n.id === noteId);
  if (note) {
    note.element.remove();
    stickyNotes = stickyNotes.filter(n => n.id !== noteId);
  }
}

function selectTool(tool) {
  currentTool = tool;
  document.querySelectorAll('.tool-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tool === tool);
  });
  imagePolygonPoints = [];
  mapPolygonPoints = [];
  
  if (tool === 'pan') {
    imageCanvas.classList.add('pan-cursor');
  } else if (tool === 'note') {
    imageCanvas.style.cursor = 'crosshair';
    imageCanvas.classList.remove('pan-cursor');
  } else {
    imageCanvas.classList.remove('pan-cursor');
  }
}

selectTool('pan');

function selectColor(color) {
  currentColor = color;
  document.getElementById('colorPicker').value = color;
}

function toggleLineStyle() {
  isDashed = !isDashed;
  const btn = document.getElementById('solidToggle');
  btn.textContent = isDashed ? 'Dashed' : 'Solid';
  btn.classList.toggle('active', !isDashed);
}

function toggleFill() {
  isFilled = !isFilled;
  const btn = document.getElementById('fillToggle');
  btn.classList.toggle('active', isFilled);
}

function updateFillOpacity(value) {
  fillOpacity = parseInt(value);
  document.getElementById('opacityLabel').textContent = fillOpacity + '%';
}

function selectLineWidth(width) {
  currentLineWidth = width;
  document.querySelectorAll('[data-width]').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.width == width);
  });
}

function getCanvasCoords(e, canvas) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const px = (e.clientX - rect.left) * scaleX;
  const py = (e.clientY - rect.top) * scaleY;
  const worldX = (px - imagePanX) / imageZoom;
  const worldY = (py - imagePanY) / imageZoom;
  return { x: worldX, y: worldY };
}

function handleDrawingMouseDown(e) {
  const coords = getCanvasCoords(e, imageCanvas);
  
  if (currentTool === 'polygon') {
    imagePolygonPoints.push(coords);
    redrawAllLayers();
    
    ctx.fillStyle = currentColor;
    ctx.beginPath();
    ctx.arc(coords.x, coords.y, 4, 0, 2 * Math.PI);
    ctx.fill();
    
    return;
  }
  
  imageDrawing = true;
  imageStartX = coords.x;
  imageStartY = coords.y;
}

function handleDrawingMouseMove(e) {
  if (!imageDrawing) return;
  
  const coords = getCanvasCoords(e, imageCanvas);
  
  redrawAllLayers();
  
  const previewShape = {
    type: currentTool,
    color: currentColor,
    dashed: isDashed,
    lineWidth: currentLineWidth,
    filled: isFilled,
    fillOpacity: fillOpacity,
    startX: imageStartX, startY: imageStartY,
    endX: coords.x, endY: coords.y
  };
  
  drawShapeOnContext(ctx, previewShape);
}

function handleDrawingMouseUp(e) {
  if (!imageDrawing) return;
  
  const coords = getCanvasCoords(e, imageCanvas);
  
  const shape = {
    type: currentTool,
    color: currentColor,
    dashed: isDashed,
    lineWidth: currentLineWidth,
    filled: isFilled,
    fillOpacity: fillOpacity,
    startX: imageStartX, startY: imageStartY,
    endX: coords.x, endY: coords.y
  };
  
  drawingShapes.push(shape);
  imageDrawing = false;
  redrawAllLayers();
}

imageCanvas.addEventListener('dblclick', (e) => {
  if (currentTool === 'polygon' && imagePolygonPoints.length > 2) {
    const shape = {
      type: 'polygon',
      color: currentColor,
      dashed: isDashed,
      lineWidth: currentLineWidth,
      filled: isFilled,
      fillOpacity: fillOpacity,
      points: [...imagePolygonPoints]
    };
    drawingShapes.push(shape);
    imagePolygonPoints = [];
    redrawAllLayers();
  }
});

function drawShapeOnContext(context, shape) {
  context.strokeStyle = shape.color;
  context.lineWidth = shape.lineWidth || currentLineWidth;
  context.setLineDash(shape.dashed ? [10, 5] : []);
  
  const opacity = shape.fillOpacity || fillOpacity;
  const opacityHex = Math.round((opacity / 100) * 255).toString(16).padStart(2, '0');
  context.fillStyle = shape.color + opacityHex;
  
  if (shape.type === 'rect') {
    const width = shape.endX - shape.startX;
    const height = shape.endY - shape.startY;
    context.strokeRect(shape.startX, shape.startY, width, height);
    if (shape.filled) {
      context.fillRect(shape.startX, shape.startY, width, height);
    }
  }
  else if (shape.type === 'circle') {
    const radius = Math.sqrt(
      Math.pow(shape.endX - shape.startX, 2) + 
      Math.pow(shape.endY - shape.startY, 2)
    );
    context.beginPath();
    context.arc(shape.startX, shape.startY, radius, 0, 2 * Math.PI);
    if (shape.filled) {
      context.fill();
    }
    context.stroke();
  }
  else if (shape.type === 'ellipse') {
    const radiusX = Math.abs(shape.endX - shape.startX);
    const radiusY = Math.abs(shape.endY - shape.startY);
    const centerX = (shape.startX + shape.endX) / 2;
    const centerY = (shape.startY + shape.endY) / 2;
    context.beginPath();
    context.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
    if (shape.filled) {
      context.fill();
    }
    context.stroke();
  }
  else if (shape.type === 'line') {
    context.beginPath();
    context.moveTo(shape.startX, shape.startY);
    context.lineTo(shape.endX, shape.endY);
    context.stroke();
  }
  else if (shape.type === 'arrow') {
    context.beginPath();
    context.moveTo(shape.startX, shape.startY);
    context.lineTo(shape.endX, shape.endY);
    context.stroke();
    
    const angle = Math.atan2(shape.endY - shape.startY, shape.endX - shape.startX);
    const arrowLength = 15;
    context.beginPath();
    context.moveTo(shape.endX, shape.endY);
    context.lineTo(
      shape.endX - arrowLength * Math.cos(angle - Math.PI / 6),
      shape.endY - arrowLength * Math.sin(angle - Math.PI / 6)
    );
    context.moveTo(shape.endX, shape.endY);
    context.lineTo(
      shape.endX - arrowLength * Math.cos(angle + Math.PI / 6),
      shape.endY - arrowLength * Math.sin(angle + Math.PI / 6)
    );
    context.stroke();
  }
  else if (shape.type === 'polygon' && shape.points) {
    context.beginPath();
    context.moveTo(shape.points[0].x, shape.points[0].y);
    shape.points.forEach(p => context.lineTo(p.x, p.y));
    context.closePath();
    if (shape.filled) {
      context.fill();
    }
    context.stroke();
    
    shape.points.forEach(p => {
      context.fillStyle = shape.color;
      context.strokeStyle = '#fff';
      context.lineWidth = 2;
      context.setLineDash([]);
      context.beginPath();
      context.arc(p.x, p.y, 5, 0, Math.PI * 2);
      context.fill();
      context.stroke();
    });
  }
  else if (shape.type === 'freehand') {
    context.beginPath();
    context.moveTo(shape.startX, shape.startY);
    context.lineTo(shape.endX, shape.endY);
    context.stroke();
  }
  
  context.setLineDash([]);
}

function undoLast() {
  // Try to delete the most recent sticky note first
  if (stickyNotes.length > 0) {
    const lastNote = stickyNotes[stickyNotes.length - 1];
    deleteStickyNote(lastNote.id);
    return;
  }
  
  // Then try shapes
  if (drawingShapes.length > 0) {
    drawingShapes.pop();
    redrawAllLayers();
  } else if (currentView === '3d' && view3DShapes.length > 0) {
    view3DShapes.pop();
    redraw3DCanvas();
  } else if (mapShapes.length > 0) {
    mapShapes.pop();
    redrawMapCanvas();
  }
}

function clearAll() {
  // Clear all sticky notes
  const notesToDelete = [...stickyNotes];
  notesToDelete.forEach(note => deleteStickyNote(note.id));
  
  // Clear shapes
  drawingShapes = [];
  redrawAllLayers();
  
  if (currentView === '3d') {
    view3DShapes = [];
    redraw3DCanvas();
  }
  mapShapes = [];
  redrawMapCanvas();
}

/* ========== IMAGE ZOOM & PAN ========== */
let imageZoom = 1;
let imagePanX = 0;
let imagePanY = 0;
let isPanning = false;
let panStartX = 0;
let panStartY = 0;

const imageContainer = document.querySelector('.image-canvas-container');

imageContainer.addEventListener('wheel', (e) => {
  if (imageLayers.length === 0) return;
  
  e.preventDefault();
  
  const delta = e.deltaY > 0 ? 0.9 : 1.1;
  const newZoom = Math.max(0.1, Math.min(imageZoom * delta, 10));
  
  const rect = imageCanvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  imagePanX = mouseX - (mouseX - imagePanX) * (newZoom / imageZoom);
  imagePanY = mouseY - (mouseY - imagePanY) * (newZoom / imageZoom);
  
  imageZoom = newZoom;
  updateImageTransform();
}, { passive: false });

imageContainer.addEventListener('mousedown', (e) => {
  const leftClick = e.button === 0;
  const midClick = e.button === 1;
  if ((midClick || (leftClick && currentTool === 'pan')) && !isDraggingLayer && !isResizingLayer) {
    e.preventDefault();
    isPanning = true;
    panStartX = e.clientX - imagePanX;
    panStartY = e.clientY - imagePanY;
    imageContainer.classList.add('panning');
  }
});

imageContainer.addEventListener('mousemove', (e) => {
  if (isPanning) {
    e.preventDefault();
    imagePanX = e.clientX - panStartX;
    imagePanY = e.clientY - panStartY;
    updateImageTransform();
  }
});

imageContainer.addEventListener('mouseup', (e) => {
  if (isPanning) {
    isPanning = false;
    imageContainer.classList.remove('panning');
  }
});

imageContainer.addEventListener('mouseleave', () => {
  if (isPanning) {
    isPanning = false;
    imageContainer.classList.remove('panning');
  }
});

imageContainer.addEventListener('dblclick', (e) => {
  if (e.target === imageContainer) {
    imageZoom = 1;
    imagePanX = 0;
    imagePanY = 0;
    updateImageTransform();
  }
});

function updateImageTransform() {
  redrawAllLayers();
}

function resetImageZoom() {
  imageZoom = 1;
  imagePanX = 0;
  imagePanY = 0;
  redrawAllLayers();
}

/* ========== LINE OF SIGHT FUNCTIONALITY ========== */
let losPointA = null, losPointB = null;
let losMarkerA = null, losMarkerB = null;
let losLine = null;
let mapboxToken = '';
let elevationOverlay = null;
let losMode = 'mapbox';
let peakFinderPanel = null;

function setLOSMode(mode) {
  losMode = mode;
  
  document.getElementById('mapboxLOSMode').classList.toggle('active', mode === 'mapbox');
  document.getElementById('peakfinderLOSMode').classList.toggle('active', mode === 'peakfinder');
  
  if (losPointA && losPointB) {
    if (mode === 'mapbox') {
      hidePeakFinder();
      initialize3DView();
    } else {
      hide3DView();
      initializePeakFinder();
    }
  }
  
  updateLOSStatus();
}

function ensureMapboxToken() {
  if (!mapboxToken) {
    const input = prompt('Enter your Mapbox access token (stored locally):');
    if (input && input.trim()) {
      mapboxToken = input.trim();
      localStorage.setItem('mapboxToken', mapboxToken);
      const tokenInput = document.getElementById('mapboxToken');
      if (tokenInput) tokenInput.value = mapboxToken;
      updateLOSStatus();
    }
  }
  return !!mapboxToken;
}

function toggleElevationOverlay() {
  if (!elevationOverlay) {
    if (!ensureMapboxToken()) {
      alert('A Mapbox token is required to enable the elevation overlay.');
      return;
    }
    const opacitySlider = document.getElementById('elevationOpacity');
    const opacity = opacitySlider ? (parseInt(opacitySlider.value, 10) / 100) : 0.6;
    elevationOverlay = L.tileLayer(
      `https://api.mapbox.com/styles/v1/mapbox/outdoors-v12/tiles/{z}/{x}/{y}?access_token=${mapboxToken}`,
      {
        tileSize: 512,
        zoomOffset: -1,
        opacity
      }
    );
    elevationOverlay.addTo(map);
    setTimeout(() => applyElevationOverlayStyles(), 0);
    const ctl = document.getElementById('elevationOpacityControl');
    if (ctl) ctl.style.display = 'block';
    document.getElementById('elevationToggle').classList.add('active');
  } else {
    map.removeLayer(elevationOverlay);
    elevationOverlay = null;
    const ctl = document.getElementById('elevationOpacityControl');
    if (ctl) ctl.style.display = 'none';
    document.getElementById('elevationToggle').classList.remove('active');
  }
}

function setElevationOpacity(value) {
  if (!elevationOverlay) return;
  const opacity = Math.max(0, Math.min(1, parseInt(value, 10) / 100));
  elevationOverlay.setOpacity(opacity);
  applyElevationOverlayStyles();
}

function setElevationEnhance(value) {
  const contrast = Math.max(100, Math.min(220, parseInt(value, 10)));
  applyElevationOverlayStyles(contrast);
}

function applyElevationOverlayStyles(contrastOverride) {
  if (!elevationOverlay || !map) return;
  const tiles = document.querySelectorAll('.leaflet-layer img, .leaflet-tile-container img');
  const desiredOpacity = typeof elevationOverlay.options.opacity === 'number' ? elevationOverlay.options.opacity : 0.6;
  const enhanceInput = document.getElementById('elevationEnhance');
  const enhanceRaw = contrastOverride || (enhanceInput ? parseInt(enhanceInput.value, 10) : 135);
  const blendSelect = document.getElementById('elevationBlend');
  let blend = blendSelect ? blendSelect.value : 'multiply';
  if (blendSelect && !blendSelect.dataset.userSet) {
    if (currentLayer === 'google' || currentLayer === 'satellite') {
      blend = 'screen';
      blendSelect.value = 'screen';
    } else {
      blend = 'multiply';
      blendSelect.value = 'multiply';
    }
  }
  const intensity = Math.max(0, Math.min(1, (enhanceRaw - 100) / 120));
  let contrastPct = 110 + Math.round(50 * intensity);
  let brightnessPct = 100 - Math.round(40 * intensity);
  let saturatePct = 110 - Math.round(20 * intensity);
  if (blend === 'screen') {
    brightnessPct = Math.max(40, brightnessPct - 10);
  }
  tiles.forEach(img => {
    if (img.src && img.src.includes('api.mapbox.com/styles/v1/mapbox/outdoors-v12/tiles')) {
      img.style.mixBlendMode = blend;
      img.style.opacity = String(desiredOpacity);
      img.style.filter = `contrast(${contrastPct}%) brightness(${brightnessPct}%) saturate(${saturatePct}%)`;
      img.style.willChange = 'filter, opacity';
      img.decoding = 'async';
      img.loading = 'lazy';
    }
  });
}

function setElevationBlend(mode) {
  const blendSelect = document.getElementById('elevationBlend');
  if (blendSelect) blendSelect.dataset.userSet = '1';
  applyElevationOverlayStyles();
}

function saveMapboxToken() {
  const token = document.getElementById('mapboxToken').value.trim();
  if (token) {
    localStorage.setItem('mapboxToken', token);
    mapboxToken = token;
    updateLOSStatus();
  }
}

function loadMapboxToken() {
  const saved = localStorage.getItem('mapboxToken');
  if (saved) {
    document.getElementById('mapboxToken').value = saved;
    mapboxToken = saved;
  }
}

function updateLOSStatus() {
  const statusEl = document.getElementById('losStatus');
  
  if (losMode === 'mapbox' && !mapboxToken) {
    statusEl.textContent = 'Enter Mapbox token for 3D mode';
    statusEl.style.background = '#fff3cd';
  } else if (!losPointA) {
    statusEl.textContent = 'Click point A (observer)';
    statusEl.style.background = '#f0f4ff';
  } else if (!losPointB) {
    statusEl.textContent = 'Click point B (target)';
    statusEl.style.background = '#f0f4ff';
  } else {
    if (losMode === 'peakfinder') {
      statusEl.textContent = 'Loading PeakFinder panorama...';
    } else {
      statusEl.textContent = 'Loading 3D terrain...';
    }
    statusEl.style.background = '#d1ecf1';
  }
}

function handleLOSClick(latlng) {
  if (losMode === 'mapbox' && !mapboxToken) {
    alert('Please enter your Mapbox access token first for 3D terrain mode.');
    return;
  }
  
  if (!losPointA) {
    losPointA = latlng;
    losMarkerA = L.marker(latlng, {
      icon: L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      })
    }).addTo(map).bindPopup('Point A (Observer)').openPopup();
    updateLOSStatus();
  } else if (!losPointB) {
    losPointB = latlng;
    losMarkerB = L.marker(latlng, {
      icon: L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      })
    }).addTo(map).bindPopup('Point B (Target)').openPopup();
    
    losLine = L.polyline([losPointA, losPointB], {
      color: '#9D2235',
      weight: 3,
      opacity: 0.7,
      dashArray: '10, 10'
    }).addTo(map);
    
    updateLOSStatus();
    
    if (losMode === 'peakfinder') {
      initializePeakFinder();
    } else {
      initialize3DView();
    }
  } else {
    clearLineOfSight();
    handleLOSClick(latlng);
  }
}

function clearLineOfSight() {
  losPointA = null;
  losPointB = null;
  
  if (losMarkerA) {
    map.removeLayer(losMarkerA);
    losMarkerA = null;
  }
  if (losMarkerB) {
    map.removeLayer(losMarkerB);
    losMarkerB = null;
  }
  if (losLine) {
    map.removeLayer(losLine);
    losLine = null;
  }
  
  if (currentView === '3d' || currentView === 'peakfinder') {
    toggleMapView();
  }
  
  if (window.map3D) {
    window.map3D.remove();
    window.map3D = null;
  }
  
  if (peakFinderPanel) {
    peakFinderPanel = null;
  }
  
  const progress = document.getElementById('pfcanvasprogress');
  if (progress) progress.style.display = 'block';
  
  updateLOSStatus();
}

async function initializePeakFinder() {
  if (!losPointA || !losPointB) return;
  
  if (typeof PeakFinder === 'undefined' || !PeakFinder.utils) {
    alert('PeakFinder library is still loading. Please wait a moment and try again.');
    return;
  }
  
  if (!PeakFinder.utils.caniuse()) {
    alert('Your browser does not support the required technologies for PeakFinder. Please try using a modern browser or switching to Mapbox 3D mode instead.');
    return;
  }
  
  const distance = L.latLng(losPointA.lat, losPointA.lng).distanceTo(L.latLng(losPointB.lat, losPointB.lng));
  const bearing = calculateBearing(losPointA, losPointB);
  
  document.getElementById('view3DDistance').textContent = `${(distance / 1000).toFixed(2)} km`;
  document.getElementById('view3DBearing').textContent = `${Math.round(bearing)}°`;
  
  if (currentView === '2d') {
    currentView = 'peakfinder';
    document.getElementById('map').style.display = 'none';
    document.getElementById('mapCanvas').style.display = 'none';
    document.getElementById('view3DContainer').classList.remove('active');
    document.getElementById('peakFinderContainer').classList.add('active');
    
    document.getElementById('viewToggleBtn').style.display = 'flex';
    document.getElementById('viewInfoBar').classList.add('visible');
    document.getElementById('viewToggleIcon').textContent = '🗺️';
    document.getElementById('viewToggleText').textContent = 'Back to 2D Map';
  }
  
  if (peakFinderPanel) {
    try {
      peakFinderPanel = null;
    } catch (e) {
      console.log('Error cleaning up PeakFinder:', e);
    }
  }
  
  try {
    peakFinderPanel = new PeakFinder.PanoramaPanel({
      canvasid: 'pfcanvas',
      locale: 'en',
      theme: 'light'
    });
    
    await peakFinderPanel.asyncinit();
    
    const progress = document.getElementById('pfcanvasprogress');
    if (progress) progress.style.display = 'none';
    
    peakFinderPanel.loadViewpoint(
      losPointA.lat,
      losPointA.lng,
      'Observer Position'
    );
    
    peakFinderPanel.addEventListener('viewpointjourney finished', async function() {
      await peakFinderPanel.azimut(bearing, 2.0);
      await peakFinderPanel.fieldofview(60.0, 1.5);
      peakFinderPanel.telescope.show();
      
      console.log(`PeakFinder initialized: viewing from A to B at ${bearing.toFixed(0)}°`);
    });
    
    try {
      peakFinderPanel.settings.distanceUnit(0);
    } catch (e) {
      console.log('PeakFinder settings configuration:', e);
    }
    
  } catch (error) {
    console.error('PeakFinder initialization error:', error);
    alert(`Failed to initialize PeakFinder: ${error.message}. Try switching to Mapbox 3D mode instead.`);
    
    const progress = document.getElementById('pfcanvasprogress');
    if (progress) progress.style.display = 'block';
  }
}

function hidePeakFinder() {
  document.getElementById('peakFinderContainer').classList.remove('active');
  if (currentView === 'peakfinder') {
    currentView = '2d';
  }
}

function hide3DView() {
  document.getElementById('view3DContainer').classList.remove('active');
}

async function initialize3DView() {
  if (!losPointA || !losPointB || !mapboxToken) return;
  
  const distance = L.latLng(losPointA.lat, losPointA.lng).distanceTo(L.latLng(losPointB.lat, losPointB.lng));
  const bearing = calculateBearing(losPointA, losPointB);
  
  document.getElementById('view3DDistance').textContent = `${(distance / 1000).toFixed(2)} km`;
  document.getElementById('view3DBearing').textContent = `${Math.round(bearing)}°`;
  
  if (currentView === '2d') {
    toggleMapView();
  }
  
  if (window.map3D) {
    window.map3D.remove();
  }
  
  mapboxgl.accessToken = mapboxToken;
  
  window.map3D = new mapboxgl.Map({
    container: 'mapbox3DContainer',
    style: 'mapbox://styles/mapbox/satellite-streets-v12',
    center: [losPointA.lng, losPointA.lat],
    zoom: 12,
    pitch: 60,
    bearing: bearing,
    antialias: true
  });
  
  window.map3D.on('load', () => {
    window.map3D.addSource('mapbox-dem', {
      'type': 'raster-dem',
      'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
      'tileSize': 512,
      'maxzoom': 14
    });
    
    window.map3D.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1.5 });
    
    window.map3D.addLayer({
      'id': 'sky',
      'type': 'sky',
      'paint': {
        'sky-type': 'atmosphere',
        'sky-atmosphere-sun': [0.0, 90.0],
        'sky-atmosphere-sun-intensity': 15
      }
    });
    
    new mapboxgl.Marker({ color: '#2ecc71' })
      .setLngLat([losPointA.lng, losPointA.lat])
      .setPopup(new mapboxgl.Popup().setHTML('Point A (Observer)'))
      .addTo(window.map3D);
    
    new mapboxgl.Marker({ color: '#e74c3c' })
      .setLngLat([losPointB.lng, losPointB.lat])
      .setPopup(new mapboxgl.Popup().setHTML('Point B (Target)'))
      .addTo(window.map3D);
    
    window.map3D.addSource('route', {
      'type': 'geojson',
      'data': {
        'type': 'Feature',
        'properties': {},
        'geometry': {
          'type': 'LineString',
          'coordinates': [
            [losPointA.lng, losPointA.lat],
            [losPointB.lng, losPointB.lat]
          ]
        }
      }
    });
    
    window.map3D.addLayer({
      'id': 'route',
      'type': 'line',
      'source': 'route',
      'layout': {
        'line-join': 'round',
        'line-cap': 'round'
      },
      'paint': {
        'line-color': '#9D2235',
        'line-width': 3,
        'line-opacity': 0.8
      }
    });
    
    console.log(`3D view initialized: ${(distance/1000).toFixed(2)}km at ${bearing.toFixed(0)}°`);
    setup3DViewCanvas();
  });
  
  window.map3D.addControl(new mapboxgl.NavigationControl());
}

const view3DCanvas = document.getElementById('view3DCanvas');
const view3DCanvasCtx = view3DCanvas.getContext('2d');
let view3DShapes = [];
let view3DDrawing = false;
let view3DStartX, view3DStartY;
let view3DPolygonPoints = [];

function setup3DViewCanvas() {
  const container = document.getElementById('view3DContainer');
  view3DCanvas.width = container.offsetWidth;
  view3DCanvas.height = container.offsetHeight;
  redraw3DCanvas();
}

function redraw3DCanvas() {
  view3DCanvasCtx.clearRect(0, 0, view3DCanvas.width, view3DCanvas.height);
  view3DShapes.forEach(shape => {
    drawShapeOnContext(view3DCanvasCtx, shape);
  });
}

view3DCanvas.addEventListener('mousedown', (e) => {
  if (currentView !== '3d' || mapMode !== 'draw') return;
  
  // Handle sticky note placement
  if (currentTool === 'note') {
    const rect = view3DCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    createStickyNote(x, y, document.getElementById('view3DContainer'));
    return;
  }
  
  const rect = view3DCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  if (currentTool === 'polygon') {
    view3DPolygonPoints.push({ x, y });
    redraw3DCanvas();
    
    view3DCanvasCtx.fillStyle = currentColor;
    view3DCanvasCtx.beginPath();
    view3DCanvasCtx.arc(x, y, 4, 0, 2 * Math.PI);
    view3DCanvasCtx.fill();
    
    return;
  }
  
  view3DDrawing = true;
  view3DStartX = x;
  view3DStartY = y;
});

view3DCanvas.addEventListener('mousemove', (e) => {
  if (!view3DDrawing || currentView !== '3d') return;
  
  const rect = view3DCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  redraw3DCanvas();
  
  const previewShape = {
    type: currentTool,
    color: currentColor,
    dashed: isDashed,
    lineWidth: currentLineWidth,
    filled: isFilled,
    fillOpacity: fillOpacity,
    startX: view3DStartX, startY: view3DStartY,
    endX: x, endY: y
  };
  
  drawShapeOnContext(view3DCanvasCtx, previewShape);
});

view3DCanvas.addEventListener('mouseup', (e) => {
  if (!view3DDrawing || currentView !== '3d') return;
  
  const rect = view3DCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const shape = {
    type: currentTool,
    color: currentColor,
    dashed: isDashed,
    lineWidth: currentLineWidth,
    filled: isFilled,
    fillOpacity: fillOpacity,
    startX: view3DStartX, startY: view3DStartY,
    endX: x, endY: y
  };
  
  view3DShapes.push(shape);
  view3DDrawing = false;
  redraw3DCanvas();
});

view3DCanvas.addEventListener('dblclick', (e) => {
  if (currentTool === 'polygon' && view3DPolygonPoints.length > 2 && currentView === '3d') {
    const shape = {
      type: 'polygon',
      color: currentColor,
      dashed: isDashed,
      lineWidth: currentLineWidth,
      filled: isFilled,
      fillOpacity: fillOpacity,
      points: [...view3DPolygonPoints]
    };
    view3DShapes.push(shape);
    view3DPolygonPoints = [];
    redraw3DCanvas();
  }
});

function calculateBearing(from, to) {
  const lat1 = from.lat * Math.PI / 180;
  const lat2 = to.lat * Math.PI / 180;
  const dLng = (to.lng - from.lng) * Math.PI / 180;
  
  const y = Math.sin(dLng) * Math.cos(lat2);
  const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLng);
  const bearing = Math.atan2(y, x) * 180 / Math.PI;
  
  return (bearing + 360) % 360;
}

/* ========== STREET VIEW & MAPILLARY ========== */
function showStreetView() {
  if (!streetViewMarker) {
    alert('Please click on the map first to select a location');
    return;
  }
  
  currentView = 'streetview';
  
  document.getElementById('map').style.display = 'none';
  document.getElementById('mapCanvas').style.display = 'none';
  document.getElementById('view3DContainer').classList.remove('active');
  document.getElementById('mapillaryContainer').classList.remove('active');
  
  const container = document.getElementById('streetViewContainer');
  container.classList.add('active');
  
  const lat = streetViewMarker.lat;
  const lng = streetViewMarker.lng;
  const iframe = document.getElementById('streetViewPano');
  
  iframe.src = `https://www.google.com/maps/embed/v1/streetview?location=${lat},${lng}&key=AIzaSyBFw0Qbyq9zTFTd-tUY6dZWTgaQzuU17R8&heading=0&pitch=0&fov=90`;
  
  console.log(`Street View loaded at ${lat}, ${lng}`);
}

async function showMapillary() {
  if (!streetViewMarker) {
    alert('Please click on the map first to select a location');
    return;
  }
  
  const lat = streetViewMarker.lat;
  const lng = streetViewMarker.lng;
  
  if (typeof mapillary === 'undefined') {
    alert('Mapillary library failed to load from CDN. This could be due to network/firewall blocking unpkg.com, ad blocker interference, or browser compatibility. Please use Google Street View instead.');
    return;
  }
  
  if (!mapillary.Viewer) {
    alert('Mapillary library loaded but Viewer class not found. Please use Google Street View instead.');
    return;
  }
  
  document.getElementById('status').textContent = 'Searching for Mapillary imagery...';
  
  try {
    const accessToken = 'MLY|4142433049200173|72206abe5035850d6743b23a49c41333';
    
    const offset = 0.001;
    const bbox = `${lng-offset},${lat-offset},${lng+offset},${lat+offset}`;
    
    const apiUrl = `https://graph.mapillary.com/images?access_token=${accessToken}&fields=id,geometry,captured_at&bbox=${bbox}&limit=1`;
    
    const response = await fetch(apiUrl);
    
    if (!response.ok) {
      throw new Error(`API request failed: ${response.status}`);
    }
    
    const data = await response.json();
    
    if (!data.data || data.data.length === 0) {
      alert('No Mapillary imagery found at this location. Try a major city (Paris, NYC, Amsterdam), urban/downtown areas, or Google Street View instead (better coverage).');
      document.getElementById('status').textContent = 'No Mapillary imagery found';
      return;
    }
    
    const imageId = data.data[0].id;
    
    currentView = 'mapillary';
    
    document.getElementById('map').style.display = 'none';
    document.getElementById('mapCanvas').style.display = 'none';
    document.getElementById('view3DContainer').classList.remove('active');
    document.getElementById('streetViewContainer').classList.remove('active');
    
    const container = document.getElementById('mapillaryContainer');
    container.classList.add('active');
    
    const viewerDiv = document.getElementById('mapillaryViewer');
    viewerDiv.innerHTML = '';
    
    if (mapillaryViewer) {
      try {
        mapillaryViewer.remove();
      } catch (e) {
        console.log('Error removing old viewer:', e);
      }
      mapillaryViewer = null;
    }
    
    const { Viewer } = mapillary;
    
    mapillaryViewer = new Viewer({
      accessToken: accessToken,
      container: 'mapillaryViewer',
      imageId: imageId
    });
    
    document.getElementById('status').textContent = 'Mapillary loaded successfully';
    
  } catch (error) {
    console.error('Mapillary error:', error);
    alert(`Failed to load Mapillary: ${error.message}. This location may not have coverage. Try Google Street View instead or a different location with better coverage.`);
    document.getElementById('status').textContent = 'Mapillary failed - try Street View';
    backToMap();
  }
}

function backToMap() {
  document.getElementById('streetViewContainer').classList.remove('active');
  document.getElementById('mapillaryContainer').classList.remove('active');
  document.getElementById('view3DContainer').classList.remove('active');
  
  document.getElementById('map').style.display = 'block';
  document.getElementById('mapCanvas').style.display = 'block';
  
  currentView = '2d';
  
  if (mapMode === 'ground' && streetViewMarker) {
    document.getElementById('streetViewControls').classList.add('visible');
  }
  
  setTimeout(() => {
    map.invalidateSize();
    if (mapMode === 'draw') resizeMapCanvas();
  }, 100);
  
  if (mapillaryViewer) {
    mapillaryViewer.remove();
    mapillaryViewer = null;
  }
}

function toggleSidebar() {
  const sidebar = document.getElementById('sidebar');
  const toggle = document.getElementById('sidebarToggle');
  const collapseBtn = sidebar.querySelector('.collapse-btn');
  
  sidebar.classList.toggle('collapsed');
  const isCollapsed = sidebar.classList.contains('collapsed');
  
  toggle.classList.toggle('visible', isCollapsed);
  collapseBtn.textContent = isCollapsed ? '▶' : '◀';
}

function toggleSummary() {
  const summary = document.getElementById('summaryPanel');
  const toggle = document.getElementById('summaryToggle');
  const collapseBtn = summary.querySelector('.collapse-btn');
  
  summary.classList.toggle('collapsed');
  const isCollapsed = summary.classList.contains('collapsed');
  
  toggle.classList.toggle('visible', isCollapsed);
  collapseBtn.textContent = isCollapsed ? '◀' : '▶';
}

function showHelp() {
  document.getElementById('helpOverlay').classList.add('visible');
}

function hideHelp() {
  document.getElementById('helpOverlay').classList.remove('visible');
}

document.getElementById('helpOverlay').addEventListener('click', (e) => {
  if (e.target === e.currentTarget) {
    hideHelp();
  }
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && document.getElementById('helpOverlay').classList.contains('visible')) {
    hideHelp();
  }
});

initFilters();
document.getElementById('streetViewControls').classList.remove('visible');
setTimeout(() => {
  map.invalidateSize();
  resizeMapCanvas();
}, 100);
  </script>
</body>
</html>